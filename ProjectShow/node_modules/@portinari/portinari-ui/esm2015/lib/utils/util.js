/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Idiomas suportados pelas páginas
/** @type {?} */
export const poLocales = ['pt', 'en', 'es', 'ru'];
// Idioma padrão
/** @type {?} */
export const poLocaleDefault = 'pt';
/**
 * @deprecated
 * Utilize o método `getShortBrowserLanguage`.
 *
 * \@description
 * Retorna idioma do browser ou o idioma padrão.
 * @return {?}
 */
export function browserLanguage() {
    return getShortBrowserLanguage();
}
/**
 * Converte e formata os bytes em formato mais legível para o usuário.
 *
 * Por exemplo:
 * - 31457280 em 30 MB.
 * - 21474836480 em 20 GB.
 * - 12.5666666 em 12.57 Bytes (duas casas decimais).
 *
 * @param {?} bytes {number} Valor em bytes
 * @param {?=} decimals {number} Quantidade de casas decimais que terá após a conversão.
 * @return {?}
 */
export function formatBytes(bytes, decimals = 2) {
    if (!bytes) {
        return undefined;
    }
    /** @type {?} */
    const multiplier = 1024;
    /** @type {?} */
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    /** @type {?} */
    const result = Math.floor(Math.log(bytes) / Math.log(multiplier));
    decimals = decimals < 0 ? 0 : decimals;
    return `${parseFloat((bytes / Math.pow(multiplier, result)).toFixed(decimals))} ${sizes[result]}`;
}
/**
 * Retorna o idioma atual do navegador
 * @return {?}
 */
export function getBrowserLanguage() {
    // navigator.userLanguage is the value for IE10
    /** @type {?} */
    const language = navigator.language || navigator['userLanguage'];
    /** @type {?} */
    const shortLanguage = getShortLanguage(language);
    return poLocales.includes(shortLanguage) ? language : poLocaleDefault;
}
/**
 * Retorna o idioma do navegador, com somente as duas primeiras letras. Por exemplo: "pt" ou "es".
 *
 * Caso o valor retornado pelo navegador não estiver dentro dos idiomas suportados pelo PO,
 * será retornado a linguagem padrão (poLocaleDefault).
 * @return {?}
 */
export function getShortBrowserLanguage() {
    return getShortLanguage(getBrowserLanguage());
}
/**
 * Retorna o idioma com somente a abreviação do idioma (duas primeiras letras).
 * Por exemplo: "pt" ou "es".
 *
 * \@default pt
 * @param {?} language {string} linguagem.
 *
 * @return {?} sigla do idioma padrão {string}.
 *
 */
export function getShortLanguage(language) {
    return (language || poLocaleDefault).toLowerCase().substring(0, 2);
}
/**
 * @param {?} value
 * @return {?}
 */
export function isLanguage(value) {
    /** @type {?} */
    const languageRegex = new RegExp('^[a-z]{2}(\-[a-z]{2})?$', 'i');
    return languageRegex.test(value);
}
/* istanbul ignore next */
/**
 * @return {?}
 */
export function reloadCurrentPage() {
    window.location.assign(location.href);
}
/**
 * @param {?} val
 * @return {?}
 */
export function convertToBoolean(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === 'on' || val === '');
    }
    if (typeof val === 'number') {
        return val === 1;
    }
    return !!val;
}
/**
 * @param {?} value
 * @param {?=} valueDefault
 * @return {?}
 */
export function convertToInt(value, valueDefault) {
    /** @type {?} */
    const validNumber = parseInt(value, 10);
    /** @type {?} */
    const validDefaultValue = parseInt(valueDefault, 10);
    /** @type {?} */
    const defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : undefined;
    return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
/**
 * @param {?} object
 * @param {?} type
 * @return {?}
 */
export function isTypeof(object, type) {
    return typeof object === type;
}
/**
 *
 * @param {?} fn Função que será executada dentro do contexto. Podendo ser o nome da função
 * ou a referência da mesma.
 *
 * @param {?} context Contexto do qual a função será executada.
 * @param {?=} param
 * @return {?}
 */
export function callFunction(fn, context, param) {
    if (isTypeof(fn, 'function')) {
        fn.call(context, param);
    }
    else {
        context[fn](param);
    }
}
/**
 * @param {?} value
 * @param {?} start
 * @param {?} end
 * @return {?}
 */
export function convertIsoToDate(value, start, end) {
    if (value) {
        /** @type {?} */
        const day = parseInt(value.substring(8, 10), 10);
        /** @type {?} */
        const month = parseInt(value.substring(5, 7), 10);
        /** @type {?} */
        const year = parseInt(value.substring(0, 4), 10);
        if (start) {
            /** @type {?} */
            const date = new Date(year, month - 1, day, 0, 0, 0);
            setYearFrom0To100(date, year);
            return date;
        }
        else if (end) {
            /** @type {?} */
            const date = new Date(year, month - 1, day, 23, 59, 59);
            setYearFrom0To100(date, year);
            return date;
        }
        else {
            /** @type {?} */
            const milliseconds = Date.parse(value);
            /** @type {?} */
            const timezone = new Date().getTimezoneOffset() * 60000;
            return new Date(milliseconds + timezone);
        }
    }
}
/**
 * @param {?} date
 * @return {?}
 */
export function convertDateToISODate(date) {
    if (date) {
        /** @type {?} */
        const getMonth = date.getMonth() + 1;
        /** @type {?} */
        const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
        /** @type {?} */
        const month = getMonth < 10 ? '0' + getMonth : getMonth;
        /** @type {?} */
        const year = formatYear(date.getFullYear());
        return year + '-' + month + '-' + day;
    }
    else {
        return null;
    }
}
/**
 * @param {?} date
 * @param {?=} time
 * @return {?}
 */
export function convertDateToISOExtended(date, time) {
    if (date) {
        /** @type {?} */
        const getMonth = date.getMonth() + 1;
        /** @type {?} */
        const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
        /** @type {?} */
        const month = getMonth < 10 ? '0' + getMonth : getMonth;
        /** @type {?} */
        const year = formatYear(date.getFullYear());
        /** @type {?} */
        const dateString = date.toString();
        if (time !== null) {
            return year + '-' + month + '-' + day + time;
        }
        else {
            return year + '-' + month + '-' + day + 'T' + dateString.substring(16, 24) +
                dateString.substring(28, 31) + ':' + dateString.substring(31, 33);
        }
    }
    else {
        return null;
    }
}
/**
 * Transforma o ano em uma string no formato yyyy e caso o ano seja menor que 1000 preenche com zeros a esquerda.
 * @param {?} year Ano
 * @return {?}
 */
export function formatYear(year) {
    if (year >= 1000) {
        return year.toString();
    }
    if (year > 99 && year < 1000) {
        return `0${year}`;
    }
    if (year > 9 && year < 100) {
        return `00${year}`;
    }
    if (year >= 0 && year < 10) {
        return `000${year}`;
    }
}
// Verifica se o navegador em que está sendo usado é Internet Explorer ou Edge
/**
 * @return {?}
 */
export function isIEOrEdge() {
    /** @type {?} */
    const userAgent = window.navigator.userAgent;
    return /msie\s|trident\/|edge\//i.test(userAgent);
}
// Verifica se o navegador em que está sendo usado é Internet Explorer
/**
 * @return {?}
 */
export function isIE() {
    /** @type {?} */
    const userAgent = window.navigator.userAgent;
    return /msie\s|trident/i.test(userAgent);
}
// Verifica qual o dispositivo que está sendo usado
/**
 * @return {?}
 */
export function isMobile() {
    /** @type {?} */
    const userAgent = window.navigator.userAgent;
    return userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i);
}
/**
 * @param {?} value
 * @param {?} comparedValue
 * @return {?}
 */
export function isEquals(value, comparedValue) {
    return JSON.stringify(value) === JSON.stringify(comparedValue);
}
/**
 * @param {?} event
 * @return {?}
 */
export function isKeyCodeEnter(event) {
    return event.keyCode === 13 || event.which === 13;
}
/**
 * Caso o ano original da data seja entre 0 e 100 atribui esse valor ao ano, pois o `new Date` do javascript transforma o ano para 190X.
 * @param {?} date Data
 * @param {?} year Ano original
 * @return {?}
 */
export function setYearFrom0To100(date, year) {
    if (year >= 0 && year < 100) {
        date.setFullYear(year);
    }
}
/**
 * @param {?} options
 * @param {?} property
 * @return {?}
 */
export function sortOptionsByProperty(options, property) {
    options.sort((/**
     * @param {?} optionA
     * @param {?} optionB
     * @return {?}
     */
    (optionA, optionB) => {
        optionA = optionA[property].toString().toLowerCase();
        optionB = optionB[property].toString().toLowerCase();
        if (optionA < optionB) {
            return -1;
        }
        if (optionA > optionB) {
            return 1;
        }
        return 0;
    }));
}
/**
 * @param {?} list
 * @return {?}
 */
export function removeDuplicatedOptions(list) {
    for (let i = 0; i < list.length; i++) {
        if (i === 0) {
            continue;
        }
        if (list.findIndex((/**
         * @param {?} op
         * @return {?}
         */
        op => op.value === list[i].value)) !== i) {
            list.splice(i, 1);
            i--;
        }
    }
}
/**
 * @param {?} list
 * @return {?}
 */
export function removeUndefinedAndNullOptions(list) {
    for (let i = 0; i < list.length; i++) {
        if (list[i].value === undefined || list[i].value === null) {
            list.splice(i, 1);
            i--;
        }
    }
}
/**
 * @param {?} value
 * @return {?}
 */
export function validValue(value) {
    return (value !== null && value !== undefined && value !== '') || value === false;
}
/**
 * @param {?} url
 * @return {?}
 */
export function isExternalLink(url) {
    return url ? url.startsWith('http') : false;
}
/**
 * @param {?} url
 * @return {?}
 */
export function openExternalLink(url) {
    window.open(url, '_blank');
}
/**
 * @param {?} link
 * @return {?}
 */
export function getFormattedLink(link) {
    /** @type {?} */
    let formattedLink = '';
    // Retira todos os pontos no começo da URL.
    if (link) {
        formattedLink = link.replace(/^(\.)+/g, '');
    }
    // Verifica se foi utilizado uma rota que não comece com barra.
    if (!formattedLink.startsWith('/')) {
        formattedLink = '/'.concat(formattedLink);
    }
    return formattedLink;
}
/**
 * Método responsável por ordenar dois valores.
 *
 * @param {?} leftSide Primeiro valor a ser comparado.
 * @param {?} rightSide Segundo valor a ser comparado.
 * @param {?=} ascending Determina se será em ordem ascendente ou descendente.
 * @return {?}
 */
export function sortValues(leftSide, rightSide, ascending = true) {
    /** @type {?} */
    const left = isTypeof(leftSide, 'string') ? leftSide.toLowerCase() : leftSide;
    /** @type {?} */
    const right = isTypeof(rightSide, 'string') ? rightSide.toLowerCase() : rightSide;
    if (ascending) {
        if (left < right) {
            return -1;
        }
        else if (left > right) {
            return 1;
        }
    }
    else if (ascending === false) {
        if (left < right) {
            return 1;
        }
        else if (left > right) {
            return -1;
        }
    }
    return 0;
}
/**
 * @param {?} date
 * @param {?} dateStart
 * @param {?} dateEnd
 * @return {?}
 */
export function validateDateRange(date, dateStart, dateEnd) {
    if (dateStart && dateEnd) {
        return (date >= dateStart && date <= dateEnd);
    }
    else if (dateStart && !dateEnd) {
        return (date >= dateStart);
    }
    else if (!dateStart && dateEnd) {
        return (date <= dateEnd);
    }
    else {
        return true;
    }
}
/**
 * @return {?}
 */
export function uuid() {
    /**
     * @return {?}
     */
    function hex4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return hex4() + hex4() + '-' + hex4() + '-' + hex4() + '-' +
        hex4() + '-' + hex4() + hex4() + hex4();
}
/**
 * @param {?} text
 * @return {?}
 */
export function capitalizeFirstLetter(text) {
    return `${text.charAt(0).toUpperCase()}${text.slice(1)}`;
}
/**
 * Mapeia um novo array apenas com as propriedades definidas pelo desenvolvedor baseado em um array de
 * origem.
 *
 * Exemplo:
 *
 * ```
 * const people = [
 *  { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 },
 *  { id: 2, name: 'Beltrano', birthdate: '1997-01-21', genre: 'Female', city: 'Joinville', dependents: 0 },
 *  { id: 3, name: 'Siclano', birthdate: '1995-07-15', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapArrayByProperties(people, properties);
 *
 * console.log(idAndName); // [{ id: 1, name: 'Fulano' }, { id: 2, name: 'Beltrano' }, { id: 3, name: 'Siclano' }]
 * ```
 *
 * Um outro uso para o método é "parear" todos os objetos do array com as mesmas propriedades.
 *
 * ```
 * const customers = [
 *  { id: 1, name: 'Fulano', city: 'São Paulo', dependents: 2 }, // sem genre
 *  { id: 2, name: 'Beltrano', genre: 'Female', city: 'Joinville' }, // sem dependents
 *  { id: 3, name: 'Siclano', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 * const properties = ['id', 'name', 'city', 'genre', 'dependents'];
 *
 * const pattern = mapArrayByProperties(customers, properties);
 * console.log(pattern);
 *
 * // [
 * //   { id: 1, name: 'Fulano', city: 'São Paulo', genre: undefined, dependents: 2 },
 * //   { id: 2, name: 'Beltrano', city: 'Joinville', genre: 'Female', dependents: undefined },
 * //   { id: 3, name: 'Siclano', city: 'Joinville', genre: 'Male', dependents: 0 }
 * // ]
 * ```
 *
 * @param {?=} items {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */
export function mapArrayByProperties(items = [], properties = []) {
    return items.map((/**
     * @param {?} item
     * @return {?}
     */
    item => mapObjectByProperties(item, properties)));
}
/**
 * Mapeia um novo objeto apenas com as propriedades definidas pelo desenvolvedor.
 *
 * Exemplo:
 *
 * ```
 * const person = { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 };
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapObjectByProperties(person, properties);
 *
 * console.log(idAndName); // { id: 1, name: 'Fulano' }
 * ```
 *
 * @param {?=} object {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */
export function mapObjectByProperties(object = {}, properties = []) {
    /** @type {?} */
    const getSelectedProperties = (/**
     * @param {?} selectedProperties
     * @param {?} property
     * @return {?}
     */
    (selectedProperties, property) => (Object.assign({}, selectedProperties, { [property]: object[property] })));
    return properties.reduce(getSelectedProperties, {});
}
/**
 * Retorna os valores de um objeto dentro de um array.
 *
 * > Simula o Object.values(obj), o mesmo deve ser removido assim que a versão typescrit for atualizada.
 *
 * @param {?=} object Objeto de onde será pego os valores.
 * @return {?}
 */
export function valuesFromObject(object = {}) {
    return Object.keys(object).map((/**
     * @param {?} property
     * @return {?}
     */
    property => object[property]));
}
/**
 * Converte um arquivo em base64.
 *
 * @param {?} file arquivo que será convertido.
 * @return {?}
 */
export function convertImageToBase64(file) {
    return new Promise((/**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    (resolve, reject) => {
        /** @type {?} */
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (/**
         * @return {?}
         */
        () => resolve(reader.result));
        reader.onerror = (/**
         * @param {?} error
         * @return {?}
         */
        error => reject(error));
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb3J0aW5hcmkvcG9ydGluYXJpLXVpLyIsInNvdXJjZXMiOlsibGliL3V0aWxzL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsTUFBTSxPQUFPLFNBQVMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQzs7O0FBRWpELE1BQU0sT0FBTyxlQUFlLEdBQUcsSUFBSTs7Ozs7Ozs7O0FBU25DLE1BQU0sVUFBVSxlQUFlO0lBQzdCLE9BQU8sdUJBQXVCLEVBQUUsQ0FBQztBQUNuQyxDQUFDOzs7Ozs7Ozs7Ozs7O0FBYUQsTUFBTSxVQUFVLFdBQVcsQ0FBQyxLQUFhLEVBQUUsUUFBUSxHQUFHLENBQUM7SUFFckQsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE9BQU8sU0FBUyxDQUFDO0tBQ2xCOztVQUVLLFVBQVUsR0FBRyxJQUFJOztVQUNqQixLQUFLLEdBQUcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQzs7VUFDakUsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2pFLFFBQVEsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztJQUV2QyxPQUFPLEdBQUcsVUFBVSxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDcEcsQ0FBQzs7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QUUvQixNQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUU7UUFFL0IsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzQixNQUFNLENBQUMsTUFBTTs7O1FBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQSxDQUFDO1FBQzdDLE1BQU0sQ0FBQyxPQUFPOzs7O1FBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUEsQ0FBQztJQUMxQyxDQUFDLEVBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJZGlvbWFzIHN1cG9ydGFkb3MgcGVsYXMgcMOhZ2luYXNcbmV4cG9ydCBjb25zdCBwb0xvY2FsZXMgPSBbJ3B0JywgJ2VuJywgJ2VzJywgJ3J1J107XG4vLyBJZGlvbWEgcGFkcsOjb1xuZXhwb3J0IGNvbnN0IHBvTG9jYWxlRGVmYXVsdCA9ICdwdCc7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIFV0aWxpemUgbyBtw6l0b2RvIGBnZXRTaG9ydEJyb3dzZXJMYW5ndWFnZWAuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXRvcm5hIGlkaW9tYSBkbyBicm93c2VyIG91IG8gaWRpb21hIHBhZHLDo28uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicm93c2VyTGFuZ3VhZ2UoKSB7XG4gIHJldHVybiBnZXRTaG9ydEJyb3dzZXJMYW5ndWFnZSgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRlIGUgZm9ybWF0YSBvcyBieXRlcyBlbSBmb3JtYXRvIG1haXMgbGVnw612ZWwgcGFyYSBvIHVzdcOhcmlvLlxuICpcbiAqIFBvciBleGVtcGxvOlxuICogLSAzMTQ1NzI4MCBlbSAzMCBNQi5cbiAqIC0gMjE0NzQ4MzY0ODAgZW0gMjAgR0IuXG4gKiAtIDEyLjU2NjY2NjYgZW0gMTIuNTcgQnl0ZXMgKGR1YXMgY2FzYXMgZGVjaW1haXMpLlxuICpcbiAqIEBwYXJhbSBieXRlcyB7bnVtYmVyfSBWYWxvciBlbSBieXRlc1xuICogQHBhcmFtIGRlY2ltYWxzIHtudW1iZXJ9IFF1YW50aWRhZGUgZGUgY2FzYXMgZGVjaW1haXMgcXVlIHRlcsOhIGFww7NzIGEgY29udmVyc8Ojby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJ5dGVzKGJ5dGVzOiBudW1iZXIsIGRlY2ltYWxzID0gMik6IHN0cmluZyB7XG5cbiAgaWYgKCFieXRlcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBtdWx0aXBsaWVyID0gMTAyNDtcbiAgY29uc3Qgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ107XG4gIGNvbnN0IHJlc3VsdCA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2cobXVsdGlwbGllcikpO1xuICBkZWNpbWFscyA9IGRlY2ltYWxzIDwgMCA/IDAgOiBkZWNpbWFscztcblxuICByZXR1cm4gYCR7cGFyc2VGbG9hdCgoYnl0ZXMgLyBNYXRoLnBvdyhtdWx0aXBsaWVyLCByZXN1bHQpKS50b0ZpeGVkKGRlY2ltYWxzKSl9ICR7c2l6ZXNbcmVzdWx0XX1gO1xufVxuXG4vKipcbiAqIFJldG9ybmEgbyBpZGlvbWEgYXR1YWwgZG8gbmF2ZWdhZG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCcm93c2VyTGFuZ3VhZ2UoKTogc3RyaW5nIHtcbiAgLy8gbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSBpcyB0aGUgdmFsdWUgZm9yIElFMTBcbiAgY29uc3QgbGFuZ3VhZ2UgPSBuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgbmF2aWdhdG9yWyd1c2VyTGFuZ3VhZ2UnXTtcbiAgY29uc3Qgc2hvcnRMYW5ndWFnZSA9IGdldFNob3J0TGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuXG4gIHJldHVybiBwb0xvY2FsZXMuaW5jbHVkZXMoc2hvcnRMYW5ndWFnZSkgPyBsYW5ndWFnZSA6IHBvTG9jYWxlRGVmYXVsdDtcbn1cblxuLyoqXG4gKiBSZXRvcm5hIG8gaWRpb21hIGRvIG5hdmVnYWRvciwgY29tIHNvbWVudGUgYXMgZHVhcyBwcmltZWlyYXMgbGV0cmFzLiBQb3IgZXhlbXBsbzogXCJwdFwiIG91IFwiZXNcIi5cbiAqXG4gKiBDYXNvIG8gdmFsb3IgcmV0b3JuYWRvIHBlbG8gbmF2ZWdhZG9yIG7Do28gZXN0aXZlciBkZW50cm8gZG9zIGlkaW9tYXMgc3Vwb3J0YWRvcyBwZWxvIFBPLFxuICogc2Vyw6EgcmV0b3JuYWRvIGEgbGluZ3VhZ2VtIHBhZHLDo28gKHBvTG9jYWxlRGVmYXVsdCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaG9ydEJyb3dzZXJMYW5ndWFnZSgpOiBzdHJpbmcge1xuICByZXR1cm4gZ2V0U2hvcnRMYW5ndWFnZShnZXRCcm93c2VyTGFuZ3VhZ2UoKSk7XG59XG5cbi8qKlxuICogUmV0b3JuYSBvIGlkaW9tYSBjb20gc29tZW50ZSBhIGFicmV2aWHDp8OjbyBkbyBpZGlvbWEgKGR1YXMgcHJpbWVpcmFzIGxldHJhcykuXG4gKiBQb3IgZXhlbXBsbzogXCJwdFwiIG91IFwiZXNcIi5cbiAqXG4gKiBAcGFyYW0gbGFuZ3VhZ2Uge3N0cmluZ30gbGluZ3VhZ2VtLlxuICpcbiAqIEByZXR1cm5zIHNpZ2xhIGRvIGlkaW9tYSBwYWRyw6NvIHtzdHJpbmd9LlxuICpcbiAqIEBkZWZhdWx0IHB0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaG9ydExhbmd1YWdlKGxhbmd1YWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gKGxhbmd1YWdlIHx8IHBvTG9jYWxlRGVmYXVsdCkudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMCwgMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xhbmd1YWdlKHZhbHVlKSB7XG4gIGNvbnN0IGxhbmd1YWdlUmVnZXggPSBuZXcgUmVnRXhwKCdeW2Etel17Mn0oXFwtW2Etel17Mn0pPyQnLCAnaScpO1xuXG4gIHJldHVybiBsYW5ndWFnZVJlZ2V4LnRlc3QodmFsdWUpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbG9hZEN1cnJlbnRQYWdlKCkge1xuICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uLmhyZWYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvQm9vbGVhbih2YWw6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgcmV0dXJuICh2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICdvbicgfHwgdmFsID09PSAnJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsID09PSAxO1xuICB9XG5cbiAgcmV0dXJuICEhdmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvSW50KHZhbHVlOiBhbnksIHZhbHVlRGVmYXVsdD86IGFueSk6IG51bWJlciB7XG4gIGNvbnN0IHZhbGlkTnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgY29uc3QgdmFsaWREZWZhdWx0VmFsdWUgPSBwYXJzZUludCh2YWx1ZURlZmF1bHQsIDEwKTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0gdmFsaWREZWZhdWx0VmFsdWUgfHwgdmFsaWREZWZhdWx0VmFsdWUgPT09IDAgPyB2YWxpZERlZmF1bHRWYWx1ZSA6IHVuZGVmaW5lZDtcblxuICByZXR1cm4gdmFsaWROdW1iZXIgfHwgdmFsaWROdW1iZXIgPT09IDAgPyB2YWxpZE51bWJlciA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZW9mKG9iamVjdDogYW55LCB0eXBlOiBhbnkpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09IHR5cGU7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBmbiBGdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIGRlbnRybyBkbyBjb250ZXh0by4gUG9kZW5kbyBzZXIgbyBub21lIGRhIGZ1bsOnw6NvXG4gKiBvdSBhIHJlZmVyw6puY2lhIGRhIG1lc21hLlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IENvbnRleHRvIGRvIHF1YWwgYSBmdW7Dp8OjbyBzZXLDoSBleGVjdXRhZGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsRnVuY3Rpb24oZm46IGFueSwgY29udGV4dDogYW55LCBwYXJhbT8pOiB2b2lkIHtcbiAgaWYgKGlzVHlwZW9mKGZuLCAnZnVuY3Rpb24nKSkge1xuICAgIGZuLmNhbGwoY29udGV4dCwgcGFyYW0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHRbZm5dKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydElzb1RvRGF0ZSh2YWx1ZTogc3RyaW5nICwgc3RhcnQ6IGJvb2xlYW4sIGVuZDogYm9vbGVhbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBjb25zdCBkYXkgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoOCwgMTApLCAxMCk7XG4gICAgY29uc3QgbW9udGggPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoNSwgNyksIDEwKTtcbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDAsIDQpLCAxMCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDAsIDAsIDApO1xuXG4gICAgICBzZXRZZWFyRnJvbTBUbzEwMChkYXRlLCB5ZWFyKTtcblxuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMjMsIDU5LCA1OSk7XG5cbiAgICAgIHNldFllYXJGcm9tMFRvMTAwKGRhdGUsIHllYXIpO1xuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWlsbGlzZWNvbmRzID0gRGF0ZS5wYXJzZSh2YWx1ZSk7XG4gICAgICBjb25zdCB0aW1lem9uZSA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpc2Vjb25kcyArIHRpbWV6b25lKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRlVG9JU09EYXRlKGRhdGU6IERhdGUpIHtcbiAgaWYgKGRhdGUpIHtcbiAgICBjb25zdCBnZXRNb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0RGF0ZSgpIDogZGF0ZS5nZXREYXRlKCk7XG4gICAgY29uc3QgbW9udGggPSBnZXRNb250aCA8IDEwID8gJzAnICsgZ2V0TW9udGggOiBnZXRNb250aDtcbiAgICBjb25zdCB5ZWFyID0gZm9ybWF0WWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuXG4gICAgcmV0dXJuIHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydERhdGVUb0lTT0V4dGVuZGVkKGRhdGU6IERhdGUsIHRpbWU/OiBzdHJpbmcpIHtcbiAgaWYgKGRhdGUpIHtcblxuICBjb25zdCBnZXRNb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpIDwgMTAgPyAnMCcgKyBkYXRlLmdldERhdGUoKSA6IGRhdGUuZ2V0RGF0ZSgpO1xuICBjb25zdCBtb250aCA9IGdldE1vbnRoIDwgMTAgPyAnMCcgKyBnZXRNb250aCA6IGdldE1vbnRoO1xuICBjb25zdCB5ZWFyID0gZm9ybWF0WWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuXG4gIGNvbnN0IGRhdGVTdHJpbmcgPSBkYXRlLnRvU3RyaW5nKCk7XG5cbiAgaWYgKHRpbWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4geWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5ICsgdGltZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5ICsgJ1QnICsgZGF0ZVN0cmluZy5zdWJzdHJpbmcoMTYsIDI0KSArXG4gICAgICAgIGRhdGVTdHJpbmcuc3Vic3RyaW5nKDI4LCAzMSkgKyAnOicgKyBkYXRlU3RyaW5nLnN1YnN0cmluZygzMSwgMzMpO1xuICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1hIG8gYW5vIGVtIHVtYSBzdHJpbmcgbm8gZm9ybWF0byB5eXl5IGUgY2FzbyBvIGFubyBzZWphIG1lbm9yIHF1ZSAxMDAwIHByZWVuY2hlIGNvbSB6ZXJvcyBhIGVzcXVlcmRhLlxuICogQHBhcmFtIHllYXIgQW5vXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRZZWFyKHllYXI6IG51bWJlcikge1xuXG4gIGlmICh5ZWFyID49IDEwMDApIHtcbiAgICByZXR1cm4geWVhci50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKHllYXIgPiA5OSAmJiB5ZWFyIDwgMTAwMCkge1xuICAgIHJldHVybiBgMCR7eWVhcn1gO1xuICB9XG5cbiAgaWYgKHllYXIgPiA5ICYmIHllYXIgPCAxMDApIHtcbiAgICByZXR1cm4gYDAwJHt5ZWFyfWA7XG4gIH1cblxuICBpZiAoeWVhciA+PSAwICYmIHllYXIgPCAxMCkge1xuICAgIHJldHVybiBgMDAwJHt5ZWFyfWA7XG4gIH1cblxufVxuLy8gVmVyaWZpY2Egc2UgbyBuYXZlZ2Fkb3IgZW0gcXVlIGVzdMOhIHNlbmRvIHVzYWRvIMOpIEludGVybmV0IEV4cGxvcmVyIG91IEVkZ2VcbmV4cG9ydCBmdW5jdGlvbiBpc0lFT3JFZGdlKCkge1xuICBjb25zdCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICByZXR1cm4gL21zaWVcXHN8dHJpZGVudFxcL3xlZGdlXFwvL2kudGVzdCh1c2VyQWdlbnQpO1xufVxuXG4vLyBWZXJpZmljYSBzZSBvIG5hdmVnYWRvciBlbSBxdWUgZXN0w6Egc2VuZG8gdXNhZG8gw6kgSW50ZXJuZXQgRXhwbG9yZXJcbmV4cG9ydCBmdW5jdGlvbiBpc0lFKCkge1xuICBjb25zdCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICByZXR1cm4gL21zaWVcXHN8dHJpZGVudC9pLnRlc3QodXNlckFnZW50KTtcbn1cblxuLy8gVmVyaWZpY2EgcXVhbCBvIGRpc3Bvc2l0aXZvIHF1ZSBlc3TDoSBzZW5kbyB1c2Fkb1xuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICBjb25zdCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICByZXR1cm4gdXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxXaW5kb3dzIFBob25lL2kpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbHModmFsdWUsIGNvbXBhcmVkVmFsdWUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoY29tcGFyZWRWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0tleUNvZGVFbnRlcihldmVudDogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBldmVudC5rZXlDb2RlID09PSAxMyB8fCBldmVudC53aGljaCA9PT0gMTM7XG59XG5cbi8qKlxuICogQ2FzbyBvIGFubyBvcmlnaW5hbCBkYSBkYXRhIHNlamEgZW50cmUgMCBlIDEwMCBhdHJpYnVpIGVzc2UgdmFsb3IgYW8gYW5vLCBwb2lzIG8gYG5ldyBEYXRlYCBkbyBqYXZhc2NyaXB0IHRyYW5zZm9ybWEgbyBhbm8gcGFyYSAxOTBYLlxuICogQHBhcmFtIGRhdGUgRGF0YVxuICogQHBhcmFtIHllYXIgQW5vIG9yaWdpbmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRZZWFyRnJvbTBUbzEwMChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIpIHtcbiAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDwgMTAwICkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRPcHRpb25zQnlQcm9wZXJ0eShvcHRpb25zOiBBcnJheTxhbnk+LCBwcm9wZXJ0eTogc3RyaW5nKSB7XG4gIG9wdGlvbnMuc29ydCgob3B0aW9uQSwgb3B0aW9uQikgPT4ge1xuICAgIG9wdGlvbkEgPSBvcHRpb25BW3Byb3BlcnR5XS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgb3B0aW9uQiA9IG9wdGlvbkJbcHJvcGVydHldLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChvcHRpb25BIDwgb3B0aW9uQikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAob3B0aW9uQSA+IG9wdGlvbkIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVkT3B0aW9ucyhsaXN0OiBBcnJheTxhbnk+KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAobGlzdC5maW5kSW5kZXgob3AgPT4gb3AudmFsdWUgPT09IGxpc3RbaV0udmFsdWUpICE9PSBpKSB7XG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEFuZE51bGxPcHRpb25zKGxpc3Q6IEFycmF5PGFueT4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3RbaV0udmFsdWUgPT09IHVuZGVmaW5lZCB8fCBsaXN0W2ldLnZhbHVlID09PSBudWxsICkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgcmV0dXJuICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSAnJykgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbExpbmsodXJsKTogYm9vbGVhbiB7XG4gIHJldHVybiB1cmwgPyB1cmwuc3RhcnRzV2l0aCgnaHR0cCcpIDogZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcGVuRXh0ZXJuYWxMaW5rKHVybCk6IHZvaWQge1xuICB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICBnZXRGb3JtYXR0ZWRMaW5rKGxpbms6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBmb3JtYXR0ZWRMaW5rID0gJyc7XG4gIC8vIFJldGlyYSB0b2RvcyBvcyBwb250b3Mgbm8gY29tZcOnbyBkYSBVUkwuXG4gIGlmIChsaW5rKSB7XG4gICAgZm9ybWF0dGVkTGluayA9IGxpbmsucmVwbGFjZSgvXihcXC4pKy9nLCAnJyk7XG4gIH1cbiAgLy8gVmVyaWZpY2Egc2UgZm9pIHV0aWxpemFkbyB1bWEgcm90YSBxdWUgbsOjbyBjb21lY2UgY29tIGJhcnJhLlxuICBpZiAoIWZvcm1hdHRlZExpbmsuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgZm9ybWF0dGVkTGluayA9ICcvJy5jb25jYXQoZm9ybWF0dGVkTGluayk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlZExpbms7XG59XG5cbi8qKlxuICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIG9yZGVuYXIgZG9pcyB2YWxvcmVzLlxuICpcbiAqIEBwYXJhbSBsZWZ0U2lkZSBQcmltZWlybyB2YWxvciBhIHNlciBjb21wYXJhZG8uXG4gKiBAcGFyYW0gcmlnaHRTaWRlIFNlZ3VuZG8gdmFsb3IgYSBzZXIgY29tcGFyYWRvLlxuICogQHBhcmFtIGFzY2VuZGluZyBEZXRlcm1pbmEgc2Ugc2Vyw6EgZW0gb3JkZW0gYXNjZW5kZW50ZSBvdSBkZXNjZW5kZW50ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRWYWx1ZXMobGVmdFNpZGU6IHN0cmluZywgcmlnaHRTaWRlOiBzdHJpbmcsIGFzY2VuZGluZzogYm9vbGVhbiA9IHRydWUpOiBudW1iZXIge1xuICBjb25zdCBsZWZ0ID0gaXNUeXBlb2YobGVmdFNpZGUsICdzdHJpbmcnKSA/IGxlZnRTaWRlLnRvTG93ZXJDYXNlKCkgOiBsZWZ0U2lkZTtcbiAgY29uc3QgcmlnaHQgPSBpc1R5cGVvZihyaWdodFNpZGUsICdzdHJpbmcnKSA/IHJpZ2h0U2lkZS50b0xvd2VyQ2FzZSgpIDogcmlnaHRTaWRlO1xuXG4gIGlmIChhc2NlbmRpbmcpIHtcbiAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChsZWZ0ID4gcmlnaHQpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhc2NlbmRpbmcgPT09IGZhbHNlKSB7XG4gICAgaWYgKGxlZnQgPCByaWdodCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChsZWZ0ID4gcmlnaHQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZURhdGVSYW5nZShkYXRlOiBEYXRlLCBkYXRlU3RhcnQ6IERhdGUsIGRhdGVFbmQ6IERhdGUpIHtcbiAgaWYgKGRhdGVTdGFydCAmJiBkYXRlRW5kKSB7XG4gICAgcmV0dXJuIChkYXRlID49IGRhdGVTdGFydCAmJiBkYXRlIDw9IGRhdGVFbmQpO1xuICB9IGVsc2UgaWYgKGRhdGVTdGFydCAmJiAhZGF0ZUVuZCkge1xuICAgIHJldHVybiAoZGF0ZSA+PSBkYXRlU3RhcnQpO1xuICB9IGVsc2UgaWYgKCFkYXRlU3RhcnQgJiYgZGF0ZUVuZCkge1xuICAgIHJldHVybiAoZGF0ZSA8PSBkYXRlRW5kKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgZnVuY3Rpb24gaGV4NCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgIC50b1N0cmluZygxNilcbiAgICAgIC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICByZXR1cm4gaGV4NCgpICsgaGV4NCgpICsgJy0nICsgaGV4NCgpICsgJy0nICsgaGV4NCgpICsgJy0nICtcbiAgaGV4NCgpICsgJy0nICsgaGV4NCgpICsgaGV4NCgpICsgaGV4NCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHt0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dGV4dC5zbGljZSgxKX1gO1xufVxuXG4vKipcbiAqIE1hcGVpYSB1bSBub3ZvIGFycmF5IGFwZW5hcyBjb20gYXMgcHJvcHJpZWRhZGVzIGRlZmluaWRhcyBwZWxvIGRlc2Vudm9sdmVkb3IgYmFzZWFkbyBlbSB1bSBhcnJheSBkZVxuICogb3JpZ2VtLlxuICpcbiAqIEV4ZW1wbG86XG4gKlxuICogYGBgXG4gKiBjb25zdCBwZW9wbGUgPSBbXG4gKiAgeyBpZDogMSwgbmFtZTogJ0Z1bGFubycsIGJpcnRoZGF0ZTogJzE5ODAtMTEtMDEnLCBnZW5yZTogJ01hbGUnLCBjaXR5OiAnU8OjbyBQYXVsbycsIGRlcGVuZGVudHM6IDIgfSxcbiAqICB7IGlkOiAyLCBuYW1lOiAnQmVsdHJhbm8nLCBiaXJ0aGRhdGU6ICcxOTk3LTAxLTIxJywgZ2VucmU6ICdGZW1hbGUnLCBjaXR5OiAnSm9pbnZpbGxlJywgZGVwZW5kZW50czogMCB9LFxuICogIHsgaWQ6IDMsIG5hbWU6ICdTaWNsYW5vJywgYmlydGhkYXRlOiAnMTk5NS0wNy0xNScsIGdlbnJlOiAnTWFsZScsIGNpdHk6ICdKb2ludmlsbGUnLCBkZXBlbmRlbnRzOiAwIH1cbiAqIF07XG4gKlxuICogY29uc3QgcHJvcGVydGllcyA9IFsnaWQnLCAnbmFtZSddO1xuICpcbiAqIGNvbnN0IGlkQW5kTmFtZSA9IG1hcEFycmF5QnlQcm9wZXJ0aWVzKHBlb3BsZSwgcHJvcGVydGllcyk7XG4gKlxuICogY29uc29sZS5sb2coaWRBbmROYW1lKTsgLy8gW3sgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nIH0sIHsgaWQ6IDIsIG5hbWU6ICdCZWx0cmFubycgfSwgeyBpZDogMywgbmFtZTogJ1NpY2xhbm8nIH1dXG4gKiBgYGBcbiAqXG4gKiBVbSBvdXRybyB1c28gcGFyYSBvIG3DqXRvZG8gw6kgXCJwYXJlYXJcIiB0b2RvcyBvcyBvYmpldG9zIGRvIGFycmF5IGNvbSBhcyBtZXNtYXMgcHJvcHJpZWRhZGVzLlxuICpcbiAqIGBgYFxuICogY29uc3QgY3VzdG9tZXJzID0gW1xuICogIHsgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nLCBjaXR5OiAnU8OjbyBQYXVsbycsIGRlcGVuZGVudHM6IDIgfSwgLy8gc2VtIGdlbnJlXG4gKiAgeyBpZDogMiwgbmFtZTogJ0JlbHRyYW5vJywgZ2VucmU6ICdGZW1hbGUnLCBjaXR5OiAnSm9pbnZpbGxlJyB9LCAvLyBzZW0gZGVwZW5kZW50c1xuICogIHsgaWQ6IDMsIG5hbWU6ICdTaWNsYW5vJywgZ2VucmU6ICdNYWxlJywgY2l0eTogJ0pvaW52aWxsZScsIGRlcGVuZGVudHM6IDAgfVxuICogXTtcbiAqIGNvbnN0IHByb3BlcnRpZXMgPSBbJ2lkJywgJ25hbWUnLCAnY2l0eScsICdnZW5yZScsICdkZXBlbmRlbnRzJ107XG4gKlxuICogY29uc3QgcGF0dGVybiA9IG1hcEFycmF5QnlQcm9wZXJ0aWVzKGN1c3RvbWVycywgcHJvcGVydGllcyk7XG4gKiBjb25zb2xlLmxvZyhwYXR0ZXJuKTtcbiAqXG4gKiAvLyBbXG4gKiAvLyAgIHsgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nLCBjaXR5OiAnU8OjbyBQYXVsbycsIGdlbnJlOiB1bmRlZmluZWQsIGRlcGVuZGVudHM6IDIgfSxcbiAqIC8vICAgeyBpZDogMiwgbmFtZTogJ0JlbHRyYW5vJywgY2l0eTogJ0pvaW52aWxsZScsIGdlbnJlOiAnRmVtYWxlJywgZGVwZW5kZW50czogdW5kZWZpbmVkIH0sXG4gKiAvLyAgIHsgaWQ6IDMsIG5hbWU6ICdTaWNsYW5vJywgY2l0eTogJ0pvaW52aWxsZScsIGdlbnJlOiAnTWFsZScsIGRlcGVuZGVudHM6IDAgfVxuICogLy8gXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGl0ZW1zIHtBcnJheTxhbnk+fSBBcnJheSBkZSBpdGVtcyBvcmlnaW5hbC5cbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIHtBcnJheTxzdHJpbmc+fSBBcnJheSBkZSBzdHJpbmcgY29tIGEgbGlzdGEgZGUgcHJvcHJpZWRhZGVzIHF1ZSBkZXZlbSBzZXIgcmV0b3JuYWRhcy5cbiAqXG4gKiBAcmV0dXJucyBBcnJheTxhbnk+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBBcnJheUJ5UHJvcGVydGllcyhpdGVtczogQXJyYXk8YW55PiA9IFtdLCBwcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+ID0gW10pOiBBcnJheTxhbnk+IHtcbiAgcmV0dXJuIGl0ZW1zLm1hcChpdGVtID0+IG1hcE9iamVjdEJ5UHJvcGVydGllcyhpdGVtLCBwcm9wZXJ0aWVzKSk7XG59XG5cbi8qKlxuICogTWFwZWlhIHVtIG5vdm8gb2JqZXRvIGFwZW5hcyBjb20gYXMgcHJvcHJpZWRhZGVzIGRlZmluaWRhcyBwZWxvIGRlc2Vudm9sdmVkb3IuXG4gKlxuICogRXhlbXBsbzpcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IHBlcnNvbiA9IHsgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nLCBiaXJ0aGRhdGU6ICcxOTgwLTExLTAxJywgZ2VucmU6ICdNYWxlJywgY2l0eTogJ1PDo28gUGF1bG8nLCBkZXBlbmRlbnRzOiAyIH07XG4gKlxuICogY29uc3QgcHJvcGVydGllcyA9IFsnaWQnLCAnbmFtZSddO1xuICpcbiAqIGNvbnN0IGlkQW5kTmFtZSA9IG1hcE9iamVjdEJ5UHJvcGVydGllcyhwZXJzb24sIHByb3BlcnRpZXMpO1xuICpcbiAqIGNvbnNvbGUubG9nKGlkQW5kTmFtZSk7IC8vIHsgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvYmplY3Qge0FycmF5PGFueT59IEFycmF5IGRlIGl0ZW1zIG9yaWdpbmFsLlxuICogQHBhcmFtIHByb3BlcnRpZXMge0FycmF5PHN0cmluZz59IEFycmF5IGRlIHN0cmluZyBjb20gYSBsaXN0YSBkZSBwcm9wcmllZGFkZXMgcXVlIGRldmVtIHNlciByZXRvcm5hZGFzLlxuICpcbiAqIEByZXR1cm5zIEFycmF5PGFueT5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9iamVjdEJ5UHJvcGVydGllcyhvYmplY3Q6IGFueSA9IHt9LCBwcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+ID0gW10pIHtcbiAgY29uc3QgZ2V0U2VsZWN0ZWRQcm9wZXJ0aWVzID0gKHNlbGVjdGVkUHJvcGVydGllcywgcHJvcGVydHkpID0+ICh7IC4uLnNlbGVjdGVkUHJvcGVydGllcywgW3Byb3BlcnR5XTogb2JqZWN0W3Byb3BlcnR5XSB9KTtcblxuICByZXR1cm4gcHJvcGVydGllcy5yZWR1Y2UoZ2V0U2VsZWN0ZWRQcm9wZXJ0aWVzLCB7fSk7XG59XG5cbi8qKlxuICogUmV0b3JuYSBvcyB2YWxvcmVzIGRlIHVtIG9iamV0byBkZW50cm8gZGUgdW0gYXJyYXkuXG4gKlxuICogPiBTaW11bGEgbyBPYmplY3QudmFsdWVzKG9iaiksIG8gbWVzbW8gZGV2ZSBzZXIgcmVtb3ZpZG8gYXNzaW0gcXVlIGEgdmVyc8OjbyB0eXBlc2NyaXQgZm9yIGF0dWFsaXphZGEuXG4gKlxuICogQHBhcmFtIG9iamVjdCBPYmpldG8gZGUgb25kZSBzZXLDoSBwZWdvIG9zIHZhbG9yZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZXNGcm9tT2JqZWN0KG9iamVjdDogYW55ID0ge30pOiBBcnJheTxhbnk+IHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKHByb3BlcnR5ID0+IG9iamVjdFtwcm9wZXJ0eV0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRlIHVtIGFycXVpdm8gZW0gYmFzZTY0LlxuICpcbiAqIEBwYXJhbSBmaWxlIGFycXVpdm8gcXVlIHNlcsOhIGNvbnZlcnRpZG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SW1hZ2VUb0Jhc2U2NChmaWxlOiBGaWxlKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICByZWFkZXIub25lcnJvciA9IGVycm9yID0+IHJlamVjdChlcnJvcik7XG4gIH0pO1xufVxuIl19