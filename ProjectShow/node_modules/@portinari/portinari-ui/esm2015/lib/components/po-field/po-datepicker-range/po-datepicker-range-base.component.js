/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter, Input, Output } from '@angular/core';
import { browserLanguage, convertToBoolean, poLocaleDefault } from './../../../utils/util';
import { requiredFailed } from '../validators';
/** @type {?} */
export const poDatepickerRangeLiteralsDefault = {
    en: (/** @type {?} */ ({
        invalidFormat: 'Date in invalid format',
        startDateGreaterThanEndDate: 'Start date greater than end date',
    })),
    es: (/** @type {?} */ ({
        invalidFormat: 'Fecha en formato no válido',
        startDateGreaterThanEndDate: 'Fecha de inicio mayor que fecha final',
    })),
    pt: (/** @type {?} */ ({
        invalidFormat: 'Data no formato inválido',
        startDateGreaterThanEndDate: 'Data inicial maior que data final',
    })),
    ru: (/** @type {?} */ ({
        invalidFormat: 'Дата в неверном формате',
        startDateGreaterThanEndDate: 'Дата начала больше даты окончания',
    }))
};
/**
 * \@description
 *
 * O `po-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `po-datepicker-range` trabalha com um objeto que implementa a interface
 * `PoDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `p-start-date` e `p-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 * @abstract
 */
export class PoDatepickerRangeBaseComponent {
    /**
     * @param {?} poDateService
     */
    constructor(poDateService) {
        this.poDateService = poDateService;
        this.errorMessage = '';
        this._clean = false;
        this._noAutocomplete = false;
        this._readonly = false;
        this._required = false;
        this.dateRange = { start: '', end: '' };
        this.format = 'dd/mm/yyyy';
        this.isDateRangeInputFormatValid = true;
        this.isStartDateRangeInputValid = true;
        /**
         * \@optional
         *
         * \@description
         *
         * Evento disparado ao alterar valor do campo.
         */
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isDateRangeInputValid() {
        return this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Habilita ação para limpar o campo.
     *
     * \@default `false`
     * @param {?} clean
     * @return {?}
     */
    set clean(clean) {
        this._clean = convertToBoolean(clean);
    }
    /**
     * @return {?}
     */
    get clean() {
        return this._clean;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Desabilita o campo.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data final.
     * @param {?} date
     * @return {?}
     */
    set endDate(date) {
        this._endDate = this.convertPatternDateFormat(date);
        this.dateRange.end = this.endDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get endDate() {
        return this._endDate;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Objeto com as literais usadas no `po-datepicker-range`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format',
     *    startDateGreaterThanEndDate: 'End date less than start date'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <po-datepicker-range
     *   [p-literals]="customLiterals">
     * </po-datepicker-range>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     * @param {?} value
     * @return {?}
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign({}, poDatepickerRangeLiteralsDefault[poLocaleDefault], poDatepickerRangeLiteralsDefault[browserLanguage()], value);
        }
        else {
            this._literals = poDatepickerRangeLiteralsDefault[browserLanguage()];
        }
    }
    /**
     * @return {?}
     */
    get literals() {
        return this._literals || poDatepickerRangeLiteralsDefault[browserLanguage()];
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Define a propriedade nativa `autocomplete` do campo como `off`.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set noAutocomplete(value) {
        this._noAutocomplete = convertToBoolean(value);
    }
    /**
     * @return {?}
     */
    get noAutocomplete() {
        return this._noAutocomplete;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será somente leitura.
     *
     * \@default `false`
     * @param {?} value
     * @return {?}
     */
    set readonly(value) {
        this._readonly = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get readonly() {
        return this._readonly;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Indica que o campo será obrigatório.
     *
     * \@default `false`
     * @param {?} required
     * @return {?}
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * \@optional
     *
     * \@description
     *
     * Data inicial.
     * @param {?} date
     * @return {?}
     */
    set startDate(date) {
        this._startDate = this.convertPatternDateFormat(date);
        this.dateRange.start = this.startDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    /**
     * @return {?}
     */
    get startDate() {
        return this._startDate;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnChange(func) {
        this.onChangeModel = func;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    /**
     * @param {?} func
     * @return {?}
     */
    registerOnTouched(func) {
        this.onTouchedModel = func;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        const value = control.value || {};
        /** @type {?} */
        const startDate = value.start ? this.convertPatternDateFormat(value.start) : '';
        /** @type {?} */
        const endDate = value.end ? this.convertPatternDateFormat(value.end) : '';
        if (this.requiredDateRangeFailed(startDate, endDate)) {
            this.errorMessage = '';
            return { required: {
                    valid: false,
                } };
        }
        if (this.dateRangeObjectFailed(control.value) || this.dateRangeFormatFailed(startDate, endDate)) {
            this.errorMessage = this.literals.invalidFormat;
            return { date: {
                    valid: false,
                } };
        }
        if (this.dateRangeFailed(startDate, endDate)) {
            this.errorMessage = this.literals.startDateGreaterThanEndDate;
            return { date: {
                    valid: false,
                } };
        }
        return null;
    }
    /**
     * @param {?} dateRange
     * @return {?}
     */
    writeValue(dateRange) {
        this.resetDateRangeInputValidation();
        if (!dateRange || this.dateRangeObjectFailed(dateRange)) {
            this.dateRange = { start: '', end: '' };
        }
        if (!dateRange) {
            this.validateModel(this.dateRange);
        }
        if (this.dateRangeObjectFailed(dateRange)) {
            this.updateModel(dateRange);
        }
        if (this.isDateRangeObject(dateRange)) {
            this.dateRange = {
                start: this.convertPatternDateFormat(dateRange.start),
                end: this.convertPatternDateFormat(dateRange.end)
            };
            this.updateModel(this.dateRange);
        }
        this.updateScreenByModel(this.dateRange);
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    dateFormatFailed(value) {
        return value && !this.poDateService.isValidIso(value);
    }
    // Executa a função onChange
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    updateModel(value) {
        /** @type {?} */
        const model = typeof (value) === 'object' ? Object.assign({}, value) : value;
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(model);
        }
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    validateModel(value) {
        /** @type {?} */
        const model = Object.assign({}, value);
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    convertPatternDateFormat(value) {
        if (value instanceof Date) {
            return this.poDateService.convertDateToISO(value);
        }
        return value;
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    dateRangeFailed(startDate, endDate) {
        return !this.poDateService.isDateRangeValid(endDate, startDate) || !this.isStartDateRangeInputValid;
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    dateRangeFormatFailed(startDate, endDate) {
        return this.dateFormatFailed(endDate) || this.dateFormatFailed(startDate) || !this.isDateRangeInputFormatValid;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    dateRangeObjectFailed(value) {
        return value && !this.isDateRangeObject(value);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isDateRangeObject(value) {
        return value && value.hasOwnProperty('start') && value.hasOwnProperty('end');
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    requiredDateRangeFailed(startDate, endDate) {
        return this.isDateRangeInputValid &&
            requiredFailed(this.required, this.disabled, startDate) &&
            requiredFailed(this.required, this.disabled, endDate);
    }
}
PoDatepickerRangeBaseComponent.propDecorators = {
    clean: [{ type: Input, args: ['p-clean',] }],
    disabled: [{ type: Input, args: ['p-disabled',] }],
    endDate: [{ type: Input, args: ['p-end-date',] }],
    help: [{ type: Input, args: ['p-help',] }],
    label: [{ type: Input, args: ['p-label',] }],
    literals: [{ type: Input, args: ['p-literals',] }],
    noAutocomplete: [{ type: Input, args: ['p-no-autocomplete',] }],
    optional: [{ type: Input, args: ['p-optional',] }],
    readonly: [{ type: Input, args: ['p-readonly',] }],
    required: [{ type: Input, args: ['p-required',] }],
    startDate: [{ type: Input, args: ['p-start-date',] }],
    onChange: [{ type: Output, args: ['p-change',] }]
};
if (false) {
    /** @type {?} */
    PoDatepickerRangeBaseComponent.prototype.errorMessage;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._clean;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._endDate;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._literals;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._noAutocomplete;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._readonly;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._required;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype._startDate;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype.onChangeModel;
    /**
     * @type {?}
     * @private
     */
    PoDatepickerRangeBaseComponent.prototype.validatorChange;
    /**
     * @type {?}
     * @protected
     */
    PoDatepickerRangeBaseComponent.prototype.dateRange;
    /**
     * @type {?}
     * @protected
     */
    PoDatepickerRangeBaseComponent.prototype.format;
    /**
     * @type {?}
     * @protected
     */
    PoDatepickerRangeBaseComponent.prototype.isDateRangeInputFormatValid;
    /**
     * @type {?}
     * @protected
     */
    PoDatepickerRangeBaseComponent.prototype.isStartDateRangeInputValid;
    /**
     * @type {?}
     * @protected
     */
    PoDatepickerRangeBaseComponent.prototype.onTouchedModel;
    /**
     * \@optional
     *
     * \@description
     *
     * Texto de apoio do campo.
     * @type {?}
     */
    PoDatepickerRangeBaseComponent.prototype.help;
    /**
     * \@optional
     *
     * \@description
     *
     * Rótulo do campo.
     * @type {?}
     */
    PoDatepickerRangeBaseComponent.prototype.label;
    /**
     * \@optional
     *
     * \@description
     *
     * Define se a indicação de campo opcional será exibida.
     *
     * > Não será exibida a indicação se:
     * - O campo conter `p-required`;
     * - Não possuir `p-help` e/ou `p-label`.
     *
     * \@default `false`
     * @type {?}
     */
    PoDatepickerRangeBaseComponent.prototype.optional;
    /**
     * \@optional
     *
     * \@description
     *
     * Evento disparado ao alterar valor do campo.
     * @type {?}
     */
    PoDatepickerRangeBaseComponent.prototype.onChange;
    /**
     * @type {?}
     * @protected
     */
    PoDatepickerRangeBaseComponent.prototype.poDateService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    PoDatepickerRangeBaseComponent.prototype.resetDateRangeInputValidation = function () { };
    /**
     * @abstract
     * @protected
     * @param {?} dateRange
     * @return {?}
     */
    PoDatepickerRangeBaseComponent.prototype.updateScreenByModel = function (dateRange) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZXBpY2tlci1yYW5nZS1iYXNlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb3J0aW5hcmkvcG9ydGluYXJpLXVpLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvcG8tZmllbGQvcG8tZGF0ZXBpY2tlci1yYW5nZS9wby1kYXRlcGlja2VyLXJhbmdlLWJhc2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFNUQsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzRixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDOztBQU0vQyxNQUFNLE9BQU8sZ0NBQWdDLEdBQUc7SUFDOUMsRUFBRSxFQUFFLG1CQUE0QjtRQUM5QixhQUFhLEVBQUUsd0JBQXdCO1FBQ3ZDLDJCQUEyQixFQUFFLGtDQUFrQztLQUNoRSxFQUFBO0lBQ0QsRUFBRSxFQUFFLG1CQUE0QjtRQUM5QixhQUFhLEVBQUUsNEJBQTRCO1FBQzNDLDJCQUEyQixFQUFFLHVDQUF1QztLQUNyRSxFQUFBO0lBQ0QsRUFBRSxFQUFFLG1CQUE0QjtRQUM5QixhQUFhLEVBQUUsMEJBQTBCO1FBQ3pDLDJCQUEyQixFQUFFLG1DQUFtQztLQUNqRSxFQUFBO0lBQ0QsRUFBRSxFQUFFLG1CQUE0QjtRQUM5QixhQUFhLEVBQUUseUJBQXlCO1FBQ3hDLDJCQUEyQixFQUFFLG1DQUFtQztLQUNqRSxFQUFBO0NBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQ0QsTUFBTSxPQUFnQiw4QkFBOEI7Ozs7SUFzUGxELFlBQXNCLGFBQTRCO1FBQTVCLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBcFBsRCxpQkFBWSxHQUFXLEVBQUUsQ0FBQztRQUVs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b250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBicm93c2VyTGFuZ3VhZ2UsIGNvbnZlcnRUb0Jvb2xlYW4sIHBvTG9jYWxlRGVmYXVsdCB9IGZyb20gJy4vLi4vLi4vLi4vdXRpbHMvdXRpbCc7XG5pbXBvcnQgeyByZXF1aXJlZEZhaWxlZCB9IGZyb20gJy4uL3ZhbGlkYXRvcnMnO1xuXG5pbXBvcnQgeyBQb0RhdGVwaWNrZXJSYW5nZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1kYXRlcGlja2VyLXJhbmdlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BvLWRhdGVwaWNrZXItcmFuZ2UtbGl0ZXJhbHMuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvRGF0ZVNlcnZpY2UgfSBmcm9tICcuLy4uLy4uLy4uL3NlcnZpY2VzL3BvLWRhdGUvcG8tZGF0ZS5zZXJ2aWNlJztcblxuZXhwb3J0IGNvbnN0IHBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHNEZWZhdWx0ID0ge1xuICBlbjogPFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHM+IHtcbiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0ZSBpbiBpbnZhbGlkIGZvcm1hdCcsXG4gICAgc3RhcnREYXRlR3JlYXRlclRoYW5FbmREYXRlOiAnU3RhcnQgZGF0ZSBncmVhdGVyIHRoYW4gZW5kIGRhdGUnLFxuICB9LFxuICBlczogPFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHM+IHtcbiAgICBpbnZhbGlkRm9ybWF0OiAnRmVjaGEgZW4gZm9ybWF0byBubyB2w6FsaWRvJyxcbiAgICBzdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU6ICdGZWNoYSBkZSBpbmljaW8gbWF5b3IgcXVlIGZlY2hhIGZpbmFsJyxcbiAgfSxcbiAgcHQ6IDxQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzPiB7XG4gICAgaW52YWxpZEZvcm1hdDogJ0RhdGEgbm8gZm9ybWF0byBpbnbDoWxpZG8nLFxuICAgIHN0YXJ0RGF0ZUdyZWF0ZXJUaGFuRW5kRGF0ZTogJ0RhdGEgaW5pY2lhbCBtYWlvciBxdWUgZGF0YSBmaW5hbCcsXG4gIH0sXG4gIHJ1OiA8UG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscz4ge1xuICAgIGludmFsaWRGb3JtYXQ6ICfQlNCw0YLQsCDQsiDQvdC10LLQtdGA0L3QvtC8INGE0L7RgNC80LDRgtC1JyxcbiAgICBzdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU6ICfQlNCw0YLQsCDQvdCw0YfQsNC70LAg0LHQvtC70YzRiNC1INC00LDRgtGLINC+0LrQvtC90YfQsNC90LjRjycsXG4gIH1cbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogTyBgcG8tZGF0ZXBpY2tlci1yYW5nZWAgw6kgdW0gY29tcG9uZW50ZSBwYXJhIHNlbGXDp8OjbyBkZSB1bSBwZXLDrW9kbyBlbnRyZSBkdWFzIGRhdGFzLCBvbmRlIMOpIHBvc3PDrXZlbCBpbmZvcm1hciBhcGVuYXNcbiAqIGEgZGF0YSBpbmljaWFsIG91IGEgZGF0YSBmaW5hbC5cbiAqXG4gKiBPIGNvbXBvbmVudGUgYFsobmdNb2RlbCldYCBkbyBgcG8tZGF0ZXBpY2tlci1yYW5nZWAgdHJhYmFsaGEgY29tIHVtIG9iamV0byBxdWUgaW1wbGVtZW50YSBhIGludGVyZmFjZVxuICogYFBvRGF0ZXBpY2tlclJhbmdlYCwgY29udGVuZG8gYXMgc2VndWludGVzIHByb3ByaWVkYWRlczpcbiAqIGBgYFxuICogeyBcInN0YXJ0XCI6ICcyMDE3LTExLTI4JywgXCJlbmRcIjogJzIwMTctMTEtMzAnIH1cbiAqIGBgYFxuICpcbiAqIDxhIGlkPVwiYWNjZXB0ZWQtZm9ybWF0c1wiPjwvYT5cbiAqIEVzdGUgY29tcG9uZW50ZSBwb2RlIHJlY2ViZXIgb3Mgc2VndWludGVzIGZvcm1hdG9zIGRlIGRhdGE6XG4gKlxuICogLSAqKkRhdGEgZSBob3JhIGNvbWJpbmFkb3MgKEU4NjAxRFp3KTogeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tKipcbiAqIGBgYFxuICogJzIwMTctMTEtMjhUMDA6MDA6MDAtMDI6MDAnO1xuICogYGBgXG4gKlxuICogLSAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKlxuICogYGBgXG4gKiAnMjAxNy0xMS0yOCc7XG4gKiBgYGBcbiAqXG4gKiAtICoqSmF2YVNjcmlwdCBEYXRlIE9iamVjdDoqKlxuICogYGBgXG4gKiBuZXcgRGF0ZSgyMDE3LCAxMCwgMjgpO1xuICogYGBgXG4gKlxuICogPiBPIGNvbXBvbmVudGUgcmVzcGVpdGFyw6EgbyBmb3JtYXRvIHBhc3NhZG8gcGFyYSBvICptb2RlbCogdmlhIGNvZGlmaWNhw6fDo28uIFBvcsOpbSwgY2FzbyBzZWphIGZlaXRhIGFsdGVyYcOnw6NvIGVtIGFsZ3VtXG4gKiBkb3MgdmFsb3JlcyBkZSBkYXRhIGVtIHRlbGEsIG8gY29tcG9uZW50ZSBhdHJpYnVpcsOhIG8gZm9ybWF0byAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKiBhbyBtb2RlbC5cbiAqXG4gKiBJbXBvcnRhbnRlOlxuICpcbiAqIC0gUXVhbmRvIHByZWVuY2hpZGFzIGEgZGF0YSBpbmljaWFsIGUgZmluYWwsIGEgZGF0YSBpbmljaWFsIGRldmUgc2VyIHNlbXByZSBtZW5vciBvdSBpZ3VhbCBhIGRhdGEgZmluYWw7XG4gKiAtIEFvIHBhc3NhciB1bWEgZGF0YSBpbnbDoWxpZGEgdmlhIGNvZGlmaWNhw6fDo28sIG8gdmFsb3Igc2Vyw6EgbWFudGlkbyBubyAqbW9kZWwqIGUgbyBgaW5wdXRgIGRhIHRlbGEgYXBhcmVjZXLDoSB2YXppbztcbiAqIC0gUGVybWl0ZSB0cmFiYWxoYXIgY29tIGFzIGR1YXMgZGF0YXMgc2VwYXJhZGFtZW50ZSBhdHJhdsOpcyBkYXMgcHJvcHJpZWRhZGVzIGBwLXN0YXJ0LWRhdGVgIGUgYHAtZW5kLWRhdGVgIG5vIGx1Z2FyIGRvXG4gKiBgWyhuZ01vZGVsKV1gLCBubyBlbnRhbnRvIHNlbSBhIHZhbGlkYcOnw6NvIGRvIGZvcm11bMOhcmlvO1xuICogLSBQYXJhIGEgdmFsaWRhw6fDo28gZG8gZm9ybXVsw6FyaW8sIHV0aWxpemUgbyBgWyhuZ01vZGVsKV1gLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUG9EYXRlcGlja2VyUmFuZ2VCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG5cbiAgZXJyb3JNZXNzYWdlOiBzdHJpbmcgPSAnJztcblxuICBwcml2YXRlIF9jbGVhbj86IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfZGlzYWJsZWQ/O1xuICBwcml2YXRlIF9lbmREYXRlPztcbiAgcHJpdmF0ZSBfbGl0ZXJhbHM/OiBhbnk7XG4gIHByaXZhdGUgX25vQXV0b2NvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9yZWFkb25seTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9yZXF1aXJlZD86IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfc3RhcnREYXRlPztcbiAgcHJpdmF0ZSBvbkNoYW5nZU1vZGVsOiBhbnk7XG4gIHByaXZhdGUgdmFsaWRhdG9yQ2hhbmdlOiBhbnk7XG5cbiAgcHJvdGVjdGVkIGRhdGVSYW5nZTogUG9EYXRlcGlja2VyUmFuZ2UgPSB7IHN0YXJ0OiAnJywgZW5kOiAnJyB9O1xuICBwcm90ZWN0ZWQgZm9ybWF0OiBhbnkgPSAnZGQvbW0veXl5eSc7XG4gIHByb3RlY3RlZCBpc0RhdGVSYW5nZUlucHV0Rm9ybWF0VmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBwcm90ZWN0ZWQgaXNTdGFydERhdGVSYW5nZUlucHV0VmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBwcm90ZWN0ZWQgb25Ub3VjaGVkTW9kZWw6IGFueTtcblxuICBnZXQgaXNEYXRlUmFuZ2VJbnB1dFZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGF0ZVJhbmdlSW5wdXRGb3JtYXRWYWxpZCAmJiB0aGlzLmlzU3RhcnREYXRlUmFuZ2VJbnB1dFZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogSGFiaWxpdGEgYcOnw6NvIHBhcmEgbGltcGFyIG8gY2FtcG8uXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIEBJbnB1dCgncC1jbGVhbicpIHNldCBjbGVhbihjbGVhbjogYm9vbGVhbikge1xuICAgIHRoaXMuX2NsZWFuID0gY29udmVydFRvQm9vbGVhbihjbGVhbik7XG4gIH1cblxuICBnZXQgY2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVzYWJpbGl0YSBvIGNhbXBvLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3AtZGlzYWJsZWQnKSBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xlYW4odmFsdWUpO1xuXG4gICAgdGhpcy52YWxpZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEYXRhIGZpbmFsLlxuICAgKi9cbiAgQElucHV0KCdwLWVuZC1kYXRlJykgc2V0IGVuZERhdGUoZGF0ZTogc3RyaW5nIHwgRGF0ZSkge1xuICAgIHRoaXMuX2VuZERhdGUgPSB0aGlzLmNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdChkYXRlKTtcbiAgICB0aGlzLmRhdGVSYW5nZS5lbmQgPSB0aGlzLmVuZERhdGU7XG5cbiAgICB0aGlzLnVwZGF0ZVNjcmVlbkJ5TW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICAgIHRoaXMudXBkYXRlTW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0IGVuZERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZERhdGU7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBUZXh0byBkZSBhcG9pbyBkbyBjYW1wby5cbiAgICovXG4gIEBJbnB1dCgncC1oZWxwJykgaGVscD86IHN0cmluZztcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBSw7N0dWxvIGRvIGNhbXBvLlxuICAgKi9cbiAgQElucHV0KCdwLWxhYmVsJykgbGFiZWw/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogT2JqZXRvIGNvbSBhcyBsaXRlcmFpcyB1c2FkYXMgbm8gYHBvLWRhdGVwaWNrZXItcmFuZ2VgLlxuICAgKlxuICAgKiBFeGlzdGVtIGR1YXMgbWFuZWlyYXMgZGUgY3VzdG9taXphciBvIGNvbXBvbmVudGUsIHBhc3NhbmRvIHVtIG9iamV0byBjb20gdG9kYXMgYXMgbGl0ZXJhaXMgZGlzcG9uw612ZWlzOlxuICAgKlxuICAgKiBgYGBcbiAgICogIGNvbnN0IGN1c3RvbUxpdGVyYWxzOiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzID0ge1xuICAgKiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0ZSBpbiBpbmNvbnNpc3RlbnQgZm9ybWF0JyxcbiAgICogICAgc3RhcnREYXRlR3JlYXRlclRoYW5FbmREYXRlOiAnRW5kIGRhdGUgbGVzcyB0aGFuIHN0YXJ0IGRhdGUnXG4gICAqICB9O1xuICAgKiBgYGBcbiAgICpcbiAgICogT3UgcGFzc2FuZG8gYXBlbmFzIGFzIGxpdGVyYWlzIHF1ZSBkZXNlamEgY3VzdG9taXphcjpcbiAgICpcbiAgICogYGBgXG4gICAqICBjb25zdCBjdXN0b21MaXRlcmFsczogUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscyA9IHtcbiAgICogICAgaW52YWxpZEZvcm1hdDogJ0RhdGUgaW4gaW5jb25zaXN0ZW50IGZvcm1hdCdcbiAgICogIH07XG4gICAqIGBgYFxuICAgKlxuICAgKiBFIHBhcmEgY2FycmVnYXIgYXMgbGl0ZXJhaXMgY3VzdG9taXphZGFzLCBiYXN0YSBhcGVuYXMgcGFzc2FyIG8gb2JqZXRvIHBhcmEgbyBjb21wb25lbnRlLlxuICAgKlxuICAgKiBgYGBcbiAgICogPHBvLWRhdGVwaWNrZXItcmFuZ2VcbiAgICogICBbcC1saXRlcmFsc109XCJjdXN0b21MaXRlcmFsc1wiPlxuICAgKiA8L3BvLWRhdGVwaWNrZXItcmFuZ2U+XG4gICAqIGBgYFxuICAgKlxuICAgKiA+IE8gb2JqZXRvIHBhZHLDo28gZGUgbGl0ZXJhaXMgc2Vyw6EgdHJhZHV6aWRvIGRlIGFjb3JkbyBjb20gbyBpZGlvbWEgZG8gYnJvd3NlciAocHQsIGVuLCBlcykuXG4gICAqL1xuICBASW5wdXQoJ3AtbGl0ZXJhbHMnKSBzZXQgbGl0ZXJhbHModmFsdWU6IFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHMpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhpcy5fbGl0ZXJhbHMgPSB7XG4gICAgICAgIC4uLnBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHNEZWZhdWx0W3BvTG9jYWxlRGVmYXVsdF0sXG4gICAgICAgIC4uLnBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHNEZWZhdWx0W2Jyb3dzZXJMYW5ndWFnZSgpXSxcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpdGVyYWxzID0gcG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFsc0RlZmF1bHRbYnJvd3Nlckxhbmd1YWdlKCldO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsaXRlcmFscygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGl0ZXJhbHMgfHwgcG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFsc0RlZmF1bHRbYnJvd3Nlckxhbmd1YWdlKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVmaW5lIGEgcHJvcHJpZWRhZGUgbmF0aXZhIGBhdXRvY29tcGxldGVgIGRvIGNhbXBvIGNvbW8gYG9mZmAuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIEBJbnB1dCgncC1uby1hdXRvY29tcGxldGUnKSBzZXQgbm9BdXRvY29tcGxldGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9ub0F1dG9jb21wbGV0ZSA9IGNvbnZlcnRUb0Jvb2xlYW4odmFsdWUpO1xuICB9XG5cbiAgZ2V0IG5vQXV0b2NvbXBsZXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9ub0F1dG9jb21wbGV0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBzZSBhIGluZGljYcOnw6NvIGRlIGNhbXBvIG9wY2lvbmFsIHNlcsOhIGV4aWJpZGEuXG4gICAqXG4gICAqID4gTsOjbyBzZXLDoSBleGliaWRhIGEgaW5kaWNhw6fDo28gc2U6XG4gICAqIC0gTyBjYW1wbyBjb250ZXIgYHAtcmVxdWlyZWRgO1xuICAgKiAtIE7Do28gcG9zc3VpciBgcC1oZWxwYCBlL291IGBwLWxhYmVsYC5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdwLW9wdGlvbmFsJykgb3B0aW9uYWw6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIHNvbWVudGUgbGVpdHVyYS5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdwLXJlYWRvbmx5Jykgc2V0IHJlYWRvbmx5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVhZG9ubHkgPSBjb252ZXJ0VG9Cb29sZWFuKHZhbHVlKTtcblxuICAgIHRoaXMudmFsaWRhdGVNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gIH1cblxuICBnZXQgcmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRvbmx5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIG9icmlnYXTDs3Jpby5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdwLXJlcXVpcmVkJykgc2V0IHJlcXVpcmVkKHJlcXVpcmVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVxdWlyZWQgPSBjb252ZXJ0VG9Cb29sZWFuKHJlcXVpcmVkKTtcblxuICAgIHRoaXMudmFsaWRhdGVNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gIH1cblxuICBnZXQgcmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVpcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGF0YSBpbmljaWFsLlxuICAgKi9cbiAgQElucHV0KCdwLXN0YXJ0LWRhdGUnKSBzZXQgc3RhcnREYXRlKGRhdGU6IHN0cmluZyB8IERhdGUpIHtcbiAgICB0aGlzLl9zdGFydERhdGUgPSB0aGlzLmNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdChkYXRlKTtcbiAgICB0aGlzLmRhdGVSYW5nZS5zdGFydCA9IHRoaXMuc3RhcnREYXRlO1xuXG4gICAgdGhpcy51cGRhdGVTY3JlZW5CeU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIGdldCBzdGFydERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIEV2ZW50byBkaXNwYXJhZG8gYW8gYWx0ZXJhciB2YWxvciBkbyBjYW1wby5cbiAgICovXG4gIEBPdXRwdXQoJ3AtY2hhbmdlJykgb25DaGFuZ2U/OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBwb0RhdGVTZXJ2aWNlOiBQb0RhdGVTZXJ2aWNlKSB7IH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVzZXREYXRlUmFuZ2VJbnB1dFZhbGlkYXRpb24oKTogdm9pZDtcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlU2NyZWVuQnlNb2RlbChkYXRlUmFuZ2U6IFBvRGF0ZXBpY2tlclJhbmdlKTtcblxuICAvLyBGdW7Dp8OjbyBpbXBsZW1lbnRhZGEgZG8gQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgLy8gVXNhZGEgcGFyYSBpbnRlcmNlcHRhciBhcyBtdWRhbsOnYXMgZSBuw6NvIGF0dWFsaXphciBhdXRvbWF0aWNhbWVudGUgbyBNb2RlbFxuICByZWdpc3Rlck9uQ2hhbmdlKGZ1bmM6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2VNb2RlbCA9IGZ1bmM7XG4gIH1cblxuICAvLyBGdW7Dp8OjbyBpbXBsZW1lbnRhZGEgZG8gQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgLy8gVXNhZGEgcGFyYSBpbnRlcmNlcHRhciBhcyBtdWRhbsOnYXMgZSBuw6NvIGF0dWFsaXphciBhdXRvbWF0aWNhbWVudGUgbyBNb2RlbFxuICByZWdpc3Rlck9uVG91Y2hlZChmdW5jOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZE1vZGVsID0gZnVuYztcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2U/KGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy52YWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuXG4gICAgY29uc3QgdmFsdWU6IFBvRGF0ZXBpY2tlclJhbmdlID0gY29udHJvbC52YWx1ZSB8fCB7fTtcbiAgICBjb25zdCBzdGFydERhdGUgPSB2YWx1ZS5zdGFydCA/IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KHZhbHVlLnN0YXJ0KSA6ICcnO1xuICAgIGNvbnN0IGVuZERhdGUgPSB2YWx1ZS5lbmQgPyB0aGlzLmNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdCh2YWx1ZS5lbmQpIDogJyc7XG5cbiAgICBpZiAodGhpcy5yZXF1aXJlZERhdGVSYW5nZUZhaWxlZChzdGFydERhdGUsIGVuZERhdGUpKSB7XG4gICAgICB0aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuXG4gICAgICByZXR1cm4geyByZXF1aXJlZDoge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICB9fTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRlUmFuZ2VPYmplY3RGYWlsZWQoY29udHJvbC52YWx1ZSkgfHwgdGhpcy5kYXRlUmFuZ2VGb3JtYXRGYWlsZWQoc3RhcnREYXRlLCBlbmREYXRlKSkge1xuICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSB0aGlzLmxpdGVyYWxzLmludmFsaWRGb3JtYXQ7XG5cbiAgICAgIHJldHVybiB7IGRhdGU6IHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgfX07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0ZVJhbmdlRmFpbGVkKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkpIHtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gdGhpcy5saXRlcmFscy5zdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU7XG5cbiAgICAgIHJldHVybiB7IGRhdGU6IHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgfX07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB3cml0ZVZhbHVlKGRhdGVSYW5nZTogUG9EYXRlcGlja2VyUmFuZ2UpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0RGF0ZVJhbmdlSW5wdXRWYWxpZGF0aW9uKCk7XG5cbiAgICBpZiAoIWRhdGVSYW5nZSB8fCB0aGlzLmRhdGVSYW5nZU9iamVjdEZhaWxlZChkYXRlUmFuZ2UpKSB7XG4gICAgICB0aGlzLmRhdGVSYW5nZSA9IHsgc3RhcnQ6ICcnLCBlbmQ6ICcnIH07XG4gICAgfVxuXG4gICAgaWYgKCFkYXRlUmFuZ2UpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0ZVJhbmdlT2JqZWN0RmFpbGVkKGRhdGVSYW5nZSkpIHtcbiAgICAgIHRoaXMudXBkYXRlTW9kZWwoZGF0ZVJhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0RhdGVSYW5nZU9iamVjdChkYXRlUmFuZ2UpKSB7XG4gICAgICB0aGlzLmRhdGVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KGRhdGVSYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogdGhpcy5jb252ZXJ0UGF0dGVybkRhdGVGb3JtYXQoZGF0ZVJhbmdlLmVuZClcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlTW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2NyZWVuQnlNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZGF0ZUZvcm1hdEZhaWxlZCh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHZhbHVlICYmICF0aGlzLnBvRGF0ZVNlcnZpY2UuaXNWYWxpZElzbyh2YWx1ZSk7XG4gIH1cblxuICAvLyBFeGVjdXRhIGEgZnVuw6fDo28gb25DaGFuZ2VcbiAgcHJvdGVjdGVkIHVwZGF0ZU1vZGVsKHZhbHVlOiBhbnkpIHtcbiAgICBjb25zdCBtb2RlbCA9IHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgLy8gUXVhbmRvIG8gaW5wdXQgbsOjbyBwb3NzdWkgdW0gZm9ybXVsw6FyaW8sIGVudMOjbyBlc3RhIGZ1bsOnw6NvIG7Do28gw6kgcmVnaXN0cmFkYVxuICAgIGlmICh0aGlzLm9uQ2hhbmdlTW9kZWwpIHtcbiAgICAgIHRoaXMub25DaGFuZ2VNb2RlbChtb2RlbCk7XG4gICAgfVxuXG4gIH1cblxuICBwcm90ZWN0ZWQgdmFsaWRhdGVNb2RlbCh2YWx1ZTogYW55KSB7XG4gICAgY29uc3QgbW9kZWwgPSB7IC4uLnZhbHVlIH07XG4gICAgaWYgKHRoaXMudmFsaWRhdG9yQ2hhbmdlKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvckNoYW5nZShtb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb252ZXJ0UGF0dGVybkRhdGVGb3JtYXQodmFsdWU6IGFueSkge1xuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucG9EYXRlU2VydmljZS5jb252ZXJ0RGF0ZVRvSVNPKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIGRhdGVSYW5nZUZhaWxlZChzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLnBvRGF0ZVNlcnZpY2UuaXNEYXRlUmFuZ2VWYWxpZChlbmREYXRlLCBzdGFydERhdGUpIHx8ICF0aGlzLmlzU3RhcnREYXRlUmFuZ2VJbnB1dFZhbGlkO1xuICB9XG5cbiAgcHJpdmF0ZSBkYXRlUmFuZ2VGb3JtYXRGYWlsZWQoc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRhdGVGb3JtYXRGYWlsZWQoZW5kRGF0ZSkgfHwgdGhpcy5kYXRlRm9ybWF0RmFpbGVkKHN0YXJ0RGF0ZSkgfHwgIXRoaXMuaXNEYXRlUmFuZ2VJbnB1dEZvcm1hdFZhbGlkO1xuICB9XG5cbiAgcHJpdmF0ZSBkYXRlUmFuZ2VPYmplY3RGYWlsZWQodmFsdWUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIXRoaXMuaXNEYXRlUmFuZ2VPYmplY3QodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0RhdGVSYW5nZU9iamVjdCh2YWx1ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnc3RhcnQnKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZW5kJyk7XG4gIH1cblxuICBwcml2YXRlIHJlcXVpcmVkRGF0ZVJhbmdlRmFpbGVkKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0RhdGVSYW5nZUlucHV0VmFsaWQgJiZcbiAgICAgIHJlcXVpcmVkRmFpbGVkKHRoaXMucmVxdWlyZWQsIHRoaXMuZGlzYWJsZWQsIHN0YXJ0RGF0ZSkgJiZcbiAgICAgIHJlcXVpcmVkRmFpbGVkKHRoaXMucmVxdWlyZWQsIHRoaXMuZGlzYWJsZWQsIGVuZERhdGUpO1xuICB9XG5cbn1cbiJdfQ==