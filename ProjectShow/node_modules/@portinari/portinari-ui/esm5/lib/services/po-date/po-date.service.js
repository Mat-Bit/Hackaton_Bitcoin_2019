/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { sortValues } from '../../utils/util';
/**
 * \@docsPrivate
 *
 * \@description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
var PoDateService = /** @class */ (function () {
    function PoDateService() {
        this.dateRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])$');
        this.isoRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])' +
            'T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|' +
            '-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])' +
            '(?:|:?[0-5]\\d)$');
    }
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param minDate Definir `true` caso seja `minDate`.
     * @param maxDate Definir `true` caso seja `maxDate`.
     */
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param {?} dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} minDate Definir `true` caso seja `minDate`.
     * @param {?} maxDate Definir `true` caso seja `maxDate`.
     * @return {?}
     */
    PoDateService.prototype.convertIsoToDate = /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param {?} dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} minDate Definir `true` caso seja `minDate`.
     * @param {?} maxDate Definir `true` caso seja `maxDate`.
     * @return {?}
     */
    function (dateString, minDate, maxDate) {
        if (dateString) {
            var _a = this.getDateFromIso(dateString), year = _a.year, month = _a.month, day = _a.day;
            if (minDate) {
                /** @type {?} */
                var date = new Date(year, month - 1, day, 0, 0, 0);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else if (maxDate) {
                /** @type {?} */
                var date = new Date(year, month - 1, day, 23, 59, 59);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else {
                /** @type {?} */
                var miliseconds = Date.parse(dateString);
                /** @type {?} */
                var timezone = new Date().getTimezoneOffset() * 60000;
                return new Date(miliseconds + timezone);
            }
        }
    };
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param date Data no formato `Date`.
     */
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param {?} date Data no formato `Date`.
     * @return {?}
     */
    PoDateService.prototype.convertDateToISO = /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param {?} date Data no formato `Date`.
     * @return {?}
     */
    function (date) {
        if (date) {
            /** @type {?} */
            var fullYear = date.getFullYear();
            /** @type {?} */
            var getMonth = date.getMonth() + 1;
            /** @type {?} */
            var day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
            /** @type {?} */
            var month = getMonth < 10 ? '0' + getMonth : getMonth;
            /** @type {?} */
            var year = this.formatYear(fullYear);
            return year + '-' + month + '-' + day;
        }
        else {
            return null;
        }
    };
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param year Ano a ser validado.
     */
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param {?} year Ano a ser validado.
     * @return {?}
     */
    PoDateService.prototype.formatYear = /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param {?} year Ano a ser validado.
     * @return {?}
     */
    function (year) {
        if (year > 999) {
            return year.toString();
        }
        if (year > 99 && year < 1000) {
            return "0" + year;
        }
        if (year > 9 && year < 100) {
            return "00" + year;
        }
        if (year >= 0 && year < 10) {
            return "000" + year;
        }
    };
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param isoDate Ano em formato string.
     */
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param {?} isoDate Ano em formato string.
     * @return {?}
     */
    PoDateService.prototype.getDateFromIso = /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param {?} isoDate Ano em formato string.
     * @return {?}
     */
    function (isoDate) {
        /** @type {?} */
        var day = parseInt(isoDate.substring(8, 10), 10);
        /** @type {?} */
        var month = parseInt(isoDate.substring(5, 7), 10);
        /** @type {?} */
        var year = parseInt(isoDate.substring(0, 4), 10);
        return { year: year, month: month, day: day };
    };
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     */
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param {?} date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     * @return {?}
     */
    PoDateService.prototype.getDateForDateRange = /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param {?} date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param {?} isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     * @return {?}
     */
    function (date, isMinDate) {
        /** @type {?} */
        var lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
        if (date instanceof Date) {
            var _a = this.splitDate(date), year = _a.year, month = _a.month, day = _a.day;
            /** @type {?} */
            var validDate = new (Date.bind.apply(Date, tslib_1.__spread([void 0, year, month, day], lastHour)))();
            this.setYearFrom0To100(validDate, year);
            return validDate;
        }
        else if (this.isValidIso(date)) {
            return this.convertIsoToDate(date, isMinDate, !isMinDate);
        }
    };
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param dateA primeira data
     * @param dateB segunda data
     */
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param {?=} dateA primeira data
     * @param {?=} dateB segunda data
     * @return {?}
     */
    PoDateService.prototype.isDateRangeValid = /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param {?=} dateA primeira data
     * @param {?=} dateB segunda data
     * @return {?}
     */
    function (dateA, dateB) {
        if (dateA === void 0) { dateA = ''; }
        if (dateB === void 0) { dateB = ''; }
        /** @type {?} */
        var dateASplitted = dateA.split('-').map((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return parseInt(item, 10); }));
        /** @type {?} */
        var dateBSplitted = dateB.split('-').map((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return parseInt(item, 10); }));
        for (var index = 0; index <= dateASplitted.length; index++) {
            if (dateASplitted[index] > dateBSplitted[index]) {
                return true;
            }
            else if (dateASplitted[index] < dateBSplitted[index]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param stringDate Data.
     */
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param {?} stringDate Data.
     * @return {?}
     */
    PoDateService.prototype.isValidIso = /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param {?} stringDate Data.
     * @return {?}
     */
    function (stringDate) {
        return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
    };
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param date Data.
     * @param year .
     */
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param {?} date Data.
     * @param {?} year .
     * @return {?}
     */
    PoDateService.prototype.setYearFrom0To100 = /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param {?} date Data.
     * @param {?} year .
     * @return {?}
     */
    function (date, year) {
        if (year >= 0 && year < 100) {
            date.setFullYear(year);
        }
    };
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param leftSide Primeira data a ser comparada.
     * @param rightSide Segunda data a ser comparada.
     * @param ascending Determina se será em ordem crescente ou decrescente.
     */
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param {?} leftSide Primeira data a ser comparada.
     * @param {?} rightSide Segunda data a ser comparada.
     * @param {?} ascending Determina se será em ordem crescente ou decrescente.
     * @return {?}
     */
    PoDateService.prototype.sortDate = /**
     * Método responsável por ordenar duas datas.
     *
     * @param {?} leftSide Primeira data a ser comparada.
     * @param {?} rightSide Segunda data a ser comparada.
     * @param {?} ascending Determina se será em ordem crescente ou decrescente.
     * @return {?}
     */
    function (leftSide, rightSide, ascending) {
        return sortValues(this.validateDate(leftSide), this.validateDate(rightSide), ascending);
    };
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param date Valor da data.
     */
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param {?} date Valor da data.
     * @return {?}
     */
    PoDateService.prototype.splitDate = /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param {?} date Valor da data.
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var year = date.getFullYear();
        /** @type {?} */
        var month = date.getMonth();
        /** @type {?} */
        var day = date.getDate();
        return { year: year, month: month, day: day };
    };
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param date Data a ser validada.
     * @param minDate Data inicial.
     * @param maxDate Data final.
     */
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param {?} date Data a ser validada.
     * @param {?} minDate Data inicial.
     * @param {?} maxDate Data final.
     * @return {?}
     */
    PoDateService.prototype.validateDateRange = /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param {?} date Data a ser validada.
     * @param {?} minDate Data inicial.
     * @param {?} maxDate Data final.
     * @return {?}
     */
    function (date, minDate, maxDate) {
        if (minDate && maxDate) {
            return (date >= minDate && date <= maxDate);
        }
        else if (minDate && !maxDate) {
            return (date >= minDate);
        }
        else if (!minDate && maxDate) {
            return (date <= maxDate);
        }
        else {
            return true;
        }
    };
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @param date Data que será validada.
     */
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @private
     * @param {?} date Data que será validada.
     * @return {?}
     */
    PoDateService.prototype.validateDate = /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @private
     * @param {?} date Data que será validada.
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var validDate = date instanceof Date ? this.convertDateToISO(date) : date;
        return this.isValidIso(validDate) ? validDate : undefined;
    };
    PoDateService.decorators = [
        { type: Injectable }
    ];
    return PoDateService;
}());
export { PoDateService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    PoDateService.prototype.dateRegex;
    /**
     * @type {?}
     * @private
     */
    PoDateService.prototype.isoRegex;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHBvcnRpbmFyaS9wb3J0aW5hcmktdWkvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvcG8tZGF0ZS9wby1kYXRlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7Ozs7Ozs7QUFTOUM7SUFBQTtRQUdtQixjQUFTLEdBQUcsSUFBSSxNQUFNLENBQUMsa0NBQWtDO1lBQzFFLG9CQUFvQjtZQUNwQiwyQkFBMkIsQ0FBQyxDQUFDO1FBRVosYUFBUSxHQUFHLElBQUksTUFBTSxDQUFDLGtDQUFrQztZQUN6RSxvQkFBb0I7WUFDcEIsMEJBQTBCO1lBQzFCLGtFQUFrRTtZQUNsRSxnREFBZ0Q7WUFDaEQsa0JBQWtCLENBQUMsQ0FBQztJQXdNdEIsQ0FBQztJQXRNQzs7Ozs7O09BTUc7Ozs7Ozs7OztJQUNILHdDQUFnQjs7Ozs7Ozs7SUFBaEIsVUFBaUIsVUFBa0IsRUFBRyxPQUFnQixFQUFFLE9BQWdCO1FBQ3RFLElBQUksVUFBVSxFQUFFO1lBQ1IsSUFBQSxvQ0FBc0QsRUFBcEQsY0FBSSxFQUFFLGdCQUFLLEVBQUUsWUFBdUM7WUFFNUQsSUFBSSxPQUFPLEVBQUU7O29CQUNMLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3BELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ25DLE9BQU8sSUFBSSxDQUFDO2FBQ2I7aUJBQU0sSUFBSSxPQUFPLEVBQUU7O29CQUNaLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLENB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Ozs7O09BTUc7Ozs7Ozs7OztJQUNILHlDQUFpQjs7Ozs7Ozs7SUFBakIsVUFBa0IsSUFBVSxFQUFFLE9BQWEsRUFBRSxPQUFhO1FBQ3hELElBQUksT0FBTyxJQUFJLE9BQU8sRUFBRTtZQUN0QixPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLENBQUM7U0FDN0M7YUFBTSxJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUM5QixPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxDQUFDO1NBQzFCO2FBQU0sSUFBSSxDQUFDLE9BQU8sSUFBSSxPQUFPLEVBQUU7WUFDOUIsT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsQ0FBQztTQUMxQjthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUM7U0FDYjtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRzs7Ozs7Ozs7O0lBQ0ssb0NBQVk7Ozs7Ozs7O0lBQXBCLFVBQXFCLElBQW1COztZQUNoQyxTQUFTLEdBQUcsSUFBSSxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO1FBRTNFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDNUQsQ0FBQzs7Z0JBbE5GLFVBQVU7O0lBb05YLG9CQUFDO0NBQUEsQUFwTkQsSUFvTkM7U0FuTlksYUFBYTs7Ozs7O0lBRXhCLGtDQUU2Qjs7Ozs7SUFFN0IsaUNBS29CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBzb3J0VmFsdWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbCc7XG5cbi8qKlxuICogQGRvY3NQcml2YXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogU2VydmnDp28gcmVzcG9uc8OhdmVsIHBvciBnZXJlbmNpYXIgbyB0cmF0YW1lbnRvIGRvcyBmb3JtYXRvcyBkZSBkYXRhIGUgaG9yYS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBvRGF0ZVNlcnZpY2Uge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OlswLTldKVxcXFxkezF9KD86WzAtOV0pXFxcXGR7MX0tJyArXG4gICcoPzowWzEtOV18MVswLTJdKS0nICtcbiAgJyg/OjBbMS05XXxbMTJdXFxcXGR8M1swMV0pJCcpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgaXNvUmVnZXggPSBuZXcgUmVnRXhwKCdeKD86WzAtOV0pXFxcXGR7MX0oPzpbMC05XSlcXFxcZHsxfS0nICtcbiAgJyg/OjBbMS05XXwxWzAtMl0pLScgK1xuICAnKD86MFsxLTldfFsxMl1cXFxcZHwzWzAxXSknICtcbiAgJ1QoPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGQoPzpafC0wWzEtOV18LTFcXFxcZHwtMlswLTNdfCcgK1xuICAnLTAwOj8oPzowWzEtOV18WzAtNV1cXFxcZCl8XFxcXCtbMDFdXFxcXGR8XFxcXCsyWzAtM10pJyArXG4gICcoPzp8Oj9bMC01XVxcXFxkKSQnKTtcblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvbnZlcnRlciBkYXRhcyBkbyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gIHBhcmEgbyBmb3JtYXRvIGBEYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGVTdHJpbmcgRGF0YSBubyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gLlxuICAgKiBAcGFyYW0gbWluRGF0ZSBEZWZpbmlyIGB0cnVlYCBjYXNvIHNlamEgYG1pbkRhdGVgLlxuICAgKiBAcGFyYW0gbWF4RGF0ZSBEZWZpbmlyIGB0cnVlYCBjYXNvIHNlamEgYG1heERhdGVgLlxuICAgKi9cbiAgY29udmVydElzb1RvRGF0ZShkYXRlU3RyaW5nOiBzdHJpbmcgLCBtaW5EYXRlOiBib29sZWFuLCBtYXhEYXRlOiBib29sZWFuKTogRGF0ZSB7XG4gICAgaWYgKGRhdGVTdHJpbmcpIHtcbiAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGhpcy5nZXREYXRlRnJvbUlzbyhkYXRlU3RyaW5nKTtcblxuICAgICAgaWYgKG1pbkRhdGUpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZXRZZWFyRnJvbTBUbzEwMChkYXRlLCB5ZWFyKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9IGVsc2UgaWYgKG1heERhdGUpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCAyMywgNTksIDU5KTtcbiAgICAgICAgdGhpcy5zZXRZZWFyRnJvbTBUbzEwMChkYXRlLCB5ZWFyKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtaWxpc2Vjb25kcyA9IERhdGUucGFyc2UoZGF0ZVN0cmluZyk7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtaWxpc2Vjb25kcyArIHRpbWV6b25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvbnZlcnRlciBkYXRhIGRvIGZvcm1hdG8gYERhdGVgIHBhcmEgbyBmb3JtYXRvIGB5eXl5LW1tLWRkYC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUgRGF0YSBubyBmb3JtYXRvIGBEYXRlYC5cbiAgICovXG4gIGNvbnZlcnREYXRlVG9JU08oZGF0ZTogRGF0ZSkge1xuICAgIGlmIChkYXRlKSB7XG4gICAgICBjb25zdCBmdWxsWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIGNvbnN0IGdldE1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpIDwgMTAgPyAnMCcgKyBkYXRlLmdldERhdGUoKSA6IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgY29uc3QgbW9udGggPSBnZXRNb250aCA8IDEwID8gJzAnICsgZ2V0TW9udGggOiBnZXRNb250aDtcbiAgICAgIGNvbnN0IHllYXIgPSB0aGlzLmZvcm1hdFllYXIoZnVsbFllYXIpO1xuICAgICAgcmV0dXJuIHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBhZGljaW9uYXIgemVyb3MgYSBlc3F1ZXJkYSBkbyBhbm9zIGVtIGZvcm1hdG8gc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geWVhciBBbm8gYSBzZXIgdmFsaWRhZG8uXG4gICAqL1xuICBmb3JtYXRZZWFyKHllYXI6IG51bWJlcikge1xuXG4gICAgaWYgKHllYXIgPiA5OTkpIHtcbiAgICAgIHJldHVybiB5ZWFyLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHllYXIgPiA5OSAmJiB5ZWFyIDwgMTAwMCkge1xuICAgICAgcmV0dXJuIGAwJHt5ZWFyfWA7XG4gICAgfVxuXG4gICAgaWYgKHllYXIgPiA5ICYmIHllYXIgPCAxMDApIHtcbiAgICAgIHJldHVybiBgMDAke3llYXJ9YDtcbiAgICB9XG5cbiAgICBpZiAoeWVhciA+PSAwICYmIHllYXIgPCAxMCkge1xuICAgICAgcmV0dXJuIGAwMDAke3llYXJ9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHJldG9ybmFyIG8gZGlhLCBtw6pzIGUgYW5vIHNlcGFyYWRvcyBlbSBmb3JtYXRvIGRlIG9iamV0by5cbiAgICpcbiAgICogQHBhcmFtIGlzb0RhdGUgQW5vIGVtIGZvcm1hdG8gc3RyaW5nLlxuICAgKi9cbiAgZ2V0RGF0ZUZyb21Jc28oaXNvRGF0ZTogc3RyaW5nKTogeyB5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGRheSA9IHBhcnNlSW50KGlzb0RhdGUuc3Vic3RyaW5nKDgsIDEwKSwgMTApO1xuICAgIGNvbnN0IG1vbnRoID0gcGFyc2VJbnQoaXNvRGF0ZS5zdWJzdHJpbmcoNSwgNyksIDEwKTtcbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQoaXNvRGF0ZS5zdWJzdHJpbmcoMCwgNCksIDEwKTtcblxuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgYSBkYXRhIGNvbSBhIGhvcmEgZGVmaW5pZGEgcGFyYSBgMDA6MDA6MDBgIGNhc28gYGlzTWluRGF0ZWAgZm9yIGlndWFsIGEgYHRydWVgIG91IGAyMzo1OTo1OWBcbiAgICogY2FzbyBgaXNNaW5kYXRlYCBzZWphIGlndWFsIGEgYGZhbHNlYCAuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgbm8gZm9ybWF0byBgRGF0ZWAgb3UgYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAuXG4gICAqIEBwYXJhbSBpc01pbkRhdGUgQ2FzbyBgdHJ1ZWAgYXBsaWNhIGAwMDowMDowMGAsIGNhc28gYGZhbHNlYCBhcGxpY2EgYDIzOjU5OjU5YCBhIGhvcmEgZGEgZGF0YSBpbmZvcm1hZGEuXG4gICAqL1xuICBnZXREYXRlRm9yRGF0ZVJhbmdlKGRhdGU6IGFueSwgaXNNaW5EYXRlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbGFzdEhvdXIgPSBpc01pbkRhdGUgPyBbMCwgMCwgMF0gOiBbMjMsIDU5LCA1OV07XG4gICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRoaXMuc3BsaXREYXRlKGRhdGUpO1xuICAgICAgY29uc3QgdmFsaWREYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgLi4ubGFzdEhvdXIpO1xuICAgICAgdGhpcy5zZXRZZWFyRnJvbTBUbzEwMCh2YWxpZERhdGUsIHllYXIpO1xuICAgICAgcmV0dXJuIHZhbGlkRGF0ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNWYWxpZElzbyhkYXRlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udmVydElzb1RvRGF0ZShkYXRlLCBpc01pbkRhdGUsICFpc01pbkRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRvcm5hIGB0cnVlYCBjYXNvIG8gcGVyw61vZG8gc2VqYSB2w6FsaWRvLCBwYXJhIGlzc28gYSBwcmltZWlyYSBkYXRhIGRldmUgc2VyIG1haW9yIHF1ZSBhIHNlZ3VuZGEgZGF0YS5cbiAgICogQHBhcmFtIGRhdGVBIHByaW1laXJhIGRhdGFcbiAgICogQHBhcmFtIGRhdGVCIHNlZ3VuZGEgZGF0YVxuICAgKi9cbiAgaXNEYXRlUmFuZ2VWYWxpZChkYXRlQTogc3RyaW5nID0gJycsIGRhdGVCOiBzdHJpbmcgPSAnJyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGRhdGVBU3BsaXR0ZWQgPSBkYXRlQS5zcGxpdCgnLScpLm1hcChpdGVtID0+IHBhcnNlSW50KGl0ZW0sIDEwKSk7XG4gICAgY29uc3QgZGF0ZUJTcGxpdHRlZCA9IGRhdGVCLnNwbGl0KCctJykubWFwKGl0ZW0gPT4gcGFyc2VJbnQoaXRlbSwgMTApKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPD0gZGF0ZUFTcGxpdHRlZC5sZW5ndGg7IGluZGV4KyspIHtcblxuICAgICAgaWYgKGRhdGVBU3BsaXR0ZWRbaW5kZXhdID4gZGF0ZUJTcGxpdHRlZFtpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRhdGVBU3BsaXR0ZWRbaW5kZXhdIDwgZGF0ZUJTcGxpdHRlZFtpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHZhbGlkYXIgc2UgdW1hIGRhdGEgZXN0w6Egbm8gZm9ybWF0byBgeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tYCBvdSBgeXl5eS1tbS1kZGAuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmdEYXRlIERhdGEuXG4gICAqL1xuICBpc1ZhbGlkSXNvKHN0cmluZ0RhdGU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmRhdGVSZWdleC50ZXN0KHN0cmluZ0RhdGUpIHx8IHRoaXMuaXNvUmVnZXgudGVzdChzdHJpbmdEYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgY29ycmlnaXIgYSBkYXRhIGNhc28gYSBtZXNtYSBlc3RlamEgZW50cmUgb3MgYW5vcyAwIGUgOTkuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEuXG4gICAqIEBwYXJhbSB5ZWFyIC5cbiAgICovXG4gIHNldFllYXJGcm9tMFRvMTAwKGRhdGU6IERhdGUsIHllYXI6IG51bWJlcikge1xuICAgIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwMCApIHtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBvcmRlbmFyIGR1YXMgZGF0YXMuXG4gICAqXG4gICAqIEBwYXJhbSBsZWZ0U2lkZSBQcmltZWlyYSBkYXRhIGEgc2VyIGNvbXBhcmFkYS5cbiAgICogQHBhcmFtIHJpZ2h0U2lkZSBTZWd1bmRhIGRhdGEgYSBzZXIgY29tcGFyYWRhLlxuICAgKiBAcGFyYW0gYXNjZW5kaW5nIERldGVybWluYSBzZSBzZXLDoSBlbSBvcmRlbSBjcmVzY2VudGUgb3UgZGVjcmVzY2VudGUuXG4gICAqL1xuICBzb3J0RGF0ZShsZWZ0U2lkZTogc3RyaW5nIHwgRGF0ZSwgcmlnaHRTaWRlOiBzdHJpbmcgfCBEYXRlLCBhc2NlbmRpbmc6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIHJldHVybiBzb3J0VmFsdWVzKHRoaXMudmFsaWRhdGVEYXRlKGxlZnRTaWRlKSwgdGhpcy52YWxpZGF0ZURhdGUocmlnaHRTaWRlKSwgYXNjZW5kaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgbyBkaWEgLCBtw6pzIGUgYW5vIGRlIHVtYSBkYXRhIGluZm9ybWFkYS5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUgVmFsb3IgZGEgZGF0YS5cbiAgICovXG4gIHNwbGl0RGF0ZShkYXRlOiBEYXRlKSB7XG4gICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHZhbGlkYXIgc2UgdW1hIGRhdGEgZXN0w6EgZW50cmUgYSBgbWluRGF0ZWAgZSBgbWF4RGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgYSBzZXIgdmFsaWRhZGEuXG4gICAqIEBwYXJhbSBtaW5EYXRlIERhdGEgaW5pY2lhbC5cbiAgICogQHBhcmFtIG1heERhdGUgRGF0YSBmaW5hbC5cbiAgICovXG4gIHZhbGlkYXRlRGF0ZVJhbmdlKGRhdGU6IERhdGUsIG1pbkRhdGU6IERhdGUsIG1heERhdGU6IERhdGUpIHtcbiAgICBpZiAobWluRGF0ZSAmJiBtYXhEYXRlKSB7XG4gICAgICByZXR1cm4gKGRhdGUgPj0gbWluRGF0ZSAmJiBkYXRlIDw9IG1heERhdGUpO1xuICAgIH0gZWxzZSBpZiAobWluRGF0ZSAmJiAhbWF4RGF0ZSkge1xuICAgICAgcmV0dXJuIChkYXRlID49IG1pbkRhdGUpO1xuICAgIH0gZWxzZSBpZiAoIW1pbkRhdGUgJiYgbWF4RGF0ZSkge1xuICAgICAgcmV0dXJuIChkYXRlIDw9IG1heERhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHZhbGlkYXIgc2UgYSBkYXRhIGZvaSBpbmZvcm1hZGEgbm9zIHBhZHLDtWVzICd5eXl5LW1tLWRkJywgJ3l5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbScgb3VcbiAgICogJ0RhdGUnIHBhZHLDo28gZG8gamF2YXNjcmlwdC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUgRGF0YSBxdWUgc2Vyw6EgdmFsaWRhZGEuXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlRGF0ZShkYXRlOiBzdHJpbmcgfCBEYXRlKSB7XG4gICAgY29uc3QgdmFsaWREYXRlID0gZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyB0aGlzLmNvbnZlcnREYXRlVG9JU08oZGF0ZSkgOiBkYXRlO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZElzbyh2YWxpZERhdGUpID8gdmFsaWREYXRlIDogdW5kZWZpbmVkO1xuICB9XG5cbn1cbiJdfQ==